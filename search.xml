<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mitmproxy与charles的抓包应用]]></title>
    <url>%2F2019%2F09%2F29%2Fmitmproxy-and-charles-use%2F</url>
    <content type="text"><![CDATA[[TOC]问题mitmproxy是命令行界面，不太方便查看，自己遇到的问题有： 在Flow Details界面不知道用哪个快捷键查看下一条或上一条网络请求详情 json中的中文显示为 \ua9b4 或 ？不能看清是哪个中文 不知道怎么复制界面中显示的内容 Charles的编程能力弱把Charles和mitmproxy结合起来使用，可以查看方便、编程扩展 环境电脑和手机都连接到同一个Wi-Fi, 比如TP_LINK_629F电脑: ip=192.168.1.100; 运行着Charles、mitmproxyCharles: 192.168.1.100:8888mitmproxy: 192.168.1.100:8080手机: 设置代理地址为Charles的地址192.168.1.100:8888 Charles - External Proxy Settings功能开启： Web Proxy(HTTP) - Web Proxy Server设置为mitmproxy的地址192.168.1.100:8080 Secure Web Proxy(HTTPS) - Secure Web Proxy Server设置为mitmproxy的地址192.168.1.100:8080 手机 Charles - External Proxy Settings 应用应用：自动生成接口的python代码 以趣头条App为例：阅读得积分的接口为: https://api.1sapp.com/readtimer/report自动生成的代码大约如下： 12345678910111213141516171819def readtimer_report(self): headers = &#123; &apos;User-Agent&apos;: &apos;qukan_android;retrofit/2.4.0 okhttp/3.11.0;os/7.0 M5 Note Meizu;device/862546036581345;version/3.9.41.000.0904.1121;channel/012&apos;, &apos;Host&apos;: &apos;api.1sapp.com&apos;, &apos;Accept-Encoding&apos;: &apos;gzip&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &#125; params = &#123; &apos;qdata&apos;: &apos;NzVFNkE3Mjc0RjEzRkYwRTM5OTEzNjAyRUZBMDMzQTAuY0dGeVlXMGZPR0kyTldKalltTXRNVGczT1MwME9EZGlMVGszT0RBdE1EUmlOVEV3TWpOak9UazRIblpsY25OcGIyNGZNVEVlY0d4aGRHWnZjbTBmWVc1a2NtOXBaQjVsWXg4eC46LxvyIvgD62/T93SlANmywpigTwlOwcfCHe0iZ1D8mH1zpslt2JCRPdiHOj1M20bU0zDX0odUOBig6Kt51mheNJuQYeDvp15R8RSGTT3LR9s55nBCGvWyTLq+3pjEvkyERElR9E2I384/nHQR4iqxqv7LKQ4rBA0R6bNG8sksHqNl1izSbF87G/4/Qw5vVYcuNUfU0BM6vvIbsy2CTPWlJ51YCzadQZZLONuaYTpyhuOiUV4vnx6qkvpYDNp9XpPPjbXxJAb7fikqjWSdyx167hXDPzUkNZGndjZsv7kQANDkIk2Dm+g5YW1I49xnkOzJkmxvyrLevnsSb9S5fSEUEyfq0GlPHE0RRBeSjFxVltH1zdZraTtk13Z+MvA7HBYQONz/0OwyMnujc1Ety91uKh6YCCVEDvBO+RTOzoRDa3nlRo3FTo9OeRBsyL20qIP24977MMYXEoxinTuwNonipCjnjSYIrhOu6cyv7uxuLd6FxtmTsydawNGMPI/K+habIKXNUFsQMCUcAGhYpoKQJvkQqHEq6lPyZZzXDot1EsN6bsGj56xQdiuJZLMFyZaGNR6E9FmVlI0LAVT8ttVpOvs+5f08T0iMxMNb0VQk6DOySpYHp7EVjc9YFpPcVxj8aXvuTjoPkaNGhSKQ0fgBd8HVRLslcnzX0QLJkTuU7NQ9aili6m2M2hWvh/q8ghWrvtLT+izCiFNKHE+4GTC9J6jqgyjHsXkAjcOSBAaIXMQKnOd664hdoR2GqV+GAy95fc5zZCJ7EFvzmTbJQrpMOwW+Y2NvYPZtgjw1uJEyU7AR7nVw7VqMjPpCDYeWBWoQ1W4OjlXTqgBR4MIu1sTag6a+my/0hItf91SNa58zCN3YmE2NnsWwwiCC+ZP91moV/KqPwX3vMLKW4/3Vsziqe8gl&apos;, &#125; data = &#123; &#125; url = &apos;http://api.1sapp.com/readtimer/report&apos; result = self._get(url, headers=headers, params=params, data=data) return result 应用步骤： 手机按上面环境设置好代理地址 在电脑上启动Charles，Charles按上面环境设置 在电脑上启动mitimproxy, 启动命令如下：mitmproxy -s gen_code_mitm.py 文件gen_code_mitm.py内容参考下面 在手机趣头条App阅读文章或看视频一定时间 会在~/Desktop/api/目录下生成一个叫readtimer_report.text 把readtimer_report.text的相应代码复制粘帖到文件qu_tou_tiao.py中 按需要修改自动生成的代码为希望的样子 运行qu_tou_tiao.py 注意： readtimer_report.text的名字和所在目录是由代码gen_code_mitm.py决定的，请自行阅读修改 readtimer_report方法名由代码gen_code_mitm.py决定的，请自行阅读修改 对body为复杂json格式的代码自动生成会有错误，有能力的自行修改 readtimer/report这个接口自动生成的代码数据是不能重复获取积分的，这里只是演示 文件文件qu_tou_tiao.py: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&apos;&apos;&apos;代码模板&apos;&apos;&apos;import requestsimport jsonimport logginglogging.basicConfig(format=&apos;%(asctime)s:%(message)s&apos;, datefmt=&apos;%m-%d %H:%M:%S&apos;, level=logging.INFO)class User(object): def __init__(self): pass def api_need_implement(self): pass def _header(self): return &#123; &apos;User-Agent&apos;: &apos;&apos;, &apos;Cookie&apos;:self.cookie &#125; @staticmethod def _post(url, data=None, json=None, p=logging.warning, **kwargs): res = requests.post(url, data=data, **kwargs) result = res.text p(res.json()) logging.info(&apos;&apos;) return result @staticmethod def _get(url, params=None, p=logging.warning, **kwargs): res = requests.get(url, params=params, **kwargs) result = res.text p(json.loads(result)) logging.info(&apos;&apos;) return resultdef genUsers(): yield User()if __name__ == &quot;__main__&quot;: for user in genUsers(): user.api_need_implement() 文件gen_code_mitm.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import jsonimport refrom urllib.parse import urlparsefrom mitmproxy import ctxfrom mitmproxy import flowfilterfrom mitmproxy import http&apos;&apos;&apos;生成接口python代码&apos;&apos;&apos;class GenCode(object): def __init__(self): ctx.log.info(&apos;__init__&apos;) # 趣头条 urls = [ r&apos;taskcenter/getListV2&apos;,#tab页：任务 r&apos;readtimer/report&apos;, ] self.qu_tou_tiao = flowfilter.parse(&apos;|&apos;.join(urls)) # 百度 - 全民小视频 urls = [ r&apos;mvideo/api&apos;, # 每日签到 ] self.quan_ming = flowfilter.parse(&apos;|&apos;.join(urls)) self.flowfilters = [ self.qu_tou_tiao, self.quan_ming, ] def load(self, loader): ctx.log.info(&apos;event: load&apos;) def configure(self, updated): ctx.log.info(&apos;event: configure&apos;) def running(self): ctx.log.info(&apos;event: running&apos;) def done(self): ctx.log.info(&apos;event: done&apos;) def response(self, flow: http.HTTPFlow): if any( [ filter(flow) for filter in self.flowfilters ] ): request: http.HTTPRequest = flow.request parse_result = urlparse(request.url) url_path = parse_result.path function_name = re.sub(r&apos;[/-]&apos;,&apos;_&apos;, url_path).strip(&apos;_&apos;) headers_code = self.headers_string(flow) params_code = self.params_string(flow) data_code = self.data_string(flow) path = f&apos;&apos;&apos;/Users/zhoujie/Desktop/api/&#123;function_name&#125;.text&apos;&apos;&apos; with open(path, &apos;a&apos;) as f: print(f&apos;&apos;&apos;# ---------------------&apos;&apos;&apos;,file=f) code = f&apos;&apos;&apos;def &#123;function_name&#125;(self): &#123;headers_code&#125; &#123;params_code&#125; &#123;data_code&#125; url = &apos;&#123;request.scheme&#125;://&#123;request.pretty_host&#125;&#123;url_path&#125;&apos; result = self._&#123;request.method.lower()&#125;(url, headers=headers, params=params, data=data) return result &apos;&apos;&apos; f.write(code) print(f&apos;&apos;&apos;Response:&apos;&apos;&apos;,file=f) print(f&apos;&apos;&apos;&#123;flow.response.text&#125;&apos;&apos;&apos;,file=f) print(f&apos;&apos;&apos;# ---------------------\n\n&apos;&apos;&apos;,file=f) def headers_string(self, flow: http.HTTPFlow): lines = &apos;&apos; for key,value in flow.request.headers.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; s = f&apos;&apos;&apos;headers = &#123;&#123;&#123;lines&#125;\n\t&#125;&#125;&apos;&apos;&apos; return s def params_string(self, flow: http.HTTPFlow): lines = &apos;&apos; for key,value in flow.request.query.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; s = f&apos;&apos;&apos;params = &#123;&#123;&#123;lines&#125;\n\t&#125;&#125;&apos;&apos;&apos; return s def data_string(self, flow: http.HTTPFlow): &apos;&apos;&apos; Content-Type: application/x-www-form-urlencoded Content-Type: application/json; charset=utf-8 Content-Type: text/plain;charset=utf-8 &apos;&apos;&apos; lines = &apos;&apos; # [urlencoded_form, multipart_form, plan, json]取其一 for key,value in flow.request.urlencoded_form.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; for key,value in flow.request.multipart_form.items(): key = key.decode(encoding=&apos;utf-8&apos;) value = value.decode(encoding=&apos;utf-8&apos;) lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; # Todo:复杂json数据还不能代码化 if &apos;application/json&apos; in flow.request.headers.get(&apos;content-type&apos;,&apos;&apos;): d = json.loads(flow.request.text) for key,value in d.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &#123;value&#125;,&quot; s = f&apos;&apos;&apos;data = &#123;&#123;&#123;lines&#125;\n\t&#125;&#125;&apos;&apos;&apos; return s addons = [ GenCode()]]]></content>
      <tags>
        <tag>mitmproxy</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles的应用]]></title>
    <url>%2F2019%2F09%2F28%2FCharles%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC]Rewrite应用案例01问题：今日头条极速版App每天的阅读推送文章任务因为每天收到的推送很少，因而不能得很高的积分，怎样把普通文章的阅读变为推送文章的阅读呢？思考：对比普通文章的阅读与推送文章的阅读发出的网络数据，找出差异普通文章的阅读与推送文章的阅读达到奖励标准时，都用相同的接口https://is.snssdk.com/score_task/v1/task/get_read_bonus/ 12345# 普通阅读文章/视频https://is.snssdk.com/score_task/v1/task/get_read_bonus/?fp=xxx&amp;...&amp;group_id=6689697061983486472# 推送文章的阅读https://is.snssdk.com/score_task/v1/task/get_read_bonus/?fp=xxx&amp;...&amp;&amp;impression_type=push&amp;group_id=6689697061983486472 对比上面的接口数据发现：推送阅读只比普通阅读多出了impression_type=push的Query String 解决：用Charles的Rewrite功能Add Query Param来增加impression_type=push解决问题 上面的get_read_bonus重写规则Export导出的get_read_bonus.xml文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos; ?&gt;&lt;?charles serialisation-version=&apos;2.0&apos; ?&gt;&lt;rewriteSet-array&gt; &lt;rewriteSet&gt; &lt;active&gt;true&lt;/active&gt; &lt;name&gt;get_read_bonus&lt;/name&gt; &lt;hosts&gt; &lt;locationPatterns&gt; &lt;locationMatch&gt; &lt;location&gt; &lt;protocol&gt;https&lt;/protocol&gt; &lt;host&gt;is.snssdk.com&lt;/host&gt; &lt;path&gt;/score_task/v1/task/get_read_bonus/&lt;/path&gt; &lt;/location&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/locationMatch&gt; &lt;/locationPatterns&gt; &lt;/hosts&gt; &lt;rules&gt; &lt;rewriteRule&gt; &lt;active&gt;true&lt;/active&gt; &lt;ruleType&gt;8&lt;/ruleType&gt; &lt;matchHeader&gt;&lt;/matchHeader&gt; &lt;matchValue&gt;&lt;/matchValue&gt; &lt;matchHeaderRegex&gt;false&lt;/matchHeaderRegex&gt; &lt;matchValueRegex&gt;false&lt;/matchValueRegex&gt; &lt;matchRequest&gt;false&lt;/matchRequest&gt; &lt;matchResponse&gt;false&lt;/matchResponse&gt; &lt;newHeader&gt;impression_type&lt;/newHeader&gt; &lt;newValue&gt;push&lt;/newValue&gt; &lt;newHeaderRegex&gt;false&lt;/newHeaderRegex&gt; &lt;newValueRegex&gt;false&lt;/newValueRegex&gt; &lt;matchWholeValue&gt;false&lt;/matchWholeValue&gt; &lt;caseSensitive&gt;false&lt;/caseSensitive&gt; &lt;replaceType&gt;2&lt;/replaceType&gt; &lt;/rewriteRule&gt; &lt;/rules&gt; &lt;/rewriteSet&gt;&lt;/rewriteSet-array&gt; 重写规则设置正确与否验证： 在上面的Notes列上会显示Rewrite Tool: query added &quot;impression_type: push&quot; 应用： 打开Charles并生效上面的Rewrite设置 手机设置代理为Charles的代理地址 正常阅读普通文章\视频达到奖励时点 查找我的收益页面，验证成功与否 案例02问题：趣消除、趣键盘、东方头条等App都看广告得金币，怎样减少广告的时间？ 思考：广告是哪里来的？广告时长是怎么来的？当点击App上的按钮弹出广告时，3个App都调用了接口： 1https://is.snssdk.com/api/ad/union/sdk/get_ads/ 响应如下： 123456789101112131415&#123;...... &quot;video&quot;: &#123; &quot;cover_height&quot;: 1280, &quot;cover_url&quot;: &quot;http://sf1-ttcdn-tos.pstatp.com/img/mosaic-legacy/1be91000a8c62c6ba6221~noop.jpg&quot;, &quot;cover_width&quot;: 720, &quot;endcard&quot;: &quot;https://www.toutiaopage.com/union/endcard/1629848424707111/?rit=909946692\u0026req_id=ED6EC127-C359-4C18-A41E-3A5F6F499250u3183\u0026ad_sdk_version=1.9.9.0\u0026os=ios\u0026lang=cn\u0026style_id=1104\u0026ad_id=1629844369912839\u0026_toutiao_params=%7B%22cid%22%3A1629848424707111%2C%22device_id%22%3A9724339963504202%2C%22log_extra%22%3A%22%7B%5C%22ad_price%5C%22%3A%5C%22XOub4AAGRWZc65vgAAZFZgz-hMMMgth42hwxAg%5C%22%2C%5C%22convert_id%5C%22%3A1629408290774020%2C%5C%22orit%5C%22%3A900000000%2C%5C%22req_id%5C%22%3A%5C%22ED6EC127-C359-4C18-A41E-3A5F6F499250u3183%5C%22%2C%5C%22rit%5C%22%3A909946692%7D%22%2C%22orit%22%3A900000000%2C%22req_id%22%3A%22ED6EC127-C359-4C18-A41E-3A5F6F499250u3183%22%2C%22rit%22%3A909946692%2C%22sign%22%3A%22D41D8CD98F00B204E9800998ECF8427E%22%2C%22uid%22%3A9724339963504202%2C%22ut%22%3A14%7D\u0026append=%7B%22openurl%22%3A%22%22%2C%22postdata%22%3A%5B%7B%22__type__%22%3A%22req_id%22%2C%22cid%22%3A1629848424707111%2C%22req_id%22%3A%22ED6EC127-C359-4C18-A41E-3A5F6F499250u3183%22%2C%22rit%22%3A909946692%7D%5D%7D&quot;, &quot;resolution&quot;: &quot;720x1280&quot;, &quot;size&quot;: 5628226, &quot;video_duration&quot;: 29.04, &quot;video_url&quot;: &quot;http://vd2.bdstatic.com/mda-jesntzw6569xqudw/mda-jesntzw6569xqudw.mp4&quot; &#125; &#125;],......&#125; 广告就是从上面的接口获取而来的，广告时长由video_url字段对应的mp4的时长决定 解决：用Charles的Rewrite功能Body替换video_url字段的值 12345Match Value:&quot;video_url&quot;:&quot;(.+)&quot;&#125;Replace Value:&quot;video_url&quot;:&quot;http://vd2.bdstatic.com/mda-jesntzw6569xqudw/mda.mp4&quot;&#125; 提供一个只有3秒的素材： 1http://vd2.bdstatic.com/mda-jesntzw6569xqudw/mda-jesntzw6569xqudw.mp4 案例03问题：章鱼输入法App有看广告得金币，没有像案例02那样找到相应的接口api返回广告视频的URL，怎样减少广告的时间？ 思考：尝试替换广告视频的请求比如广告视频的请求如下： 1234Get https://v3-ad.ixigua.com/.../video/m/.../toutiao.mp4替换为只有3秒的视频地址Get http://vd2.bdstatic.com/.../3seconds.mp4 解决：用Charles的Rewrite功能URL替换请求 案例04问题：扶我起来学数学App的作战休息区有一个游戏伪装者，在上报成绩时，接口有hash字段，修改成绩字段，hash会验证不通过，达到了防止伪造成绩的功能，怎样在hash前伪造成绩？思考：hash算法一般难破解，与其破解hash算法，不如转变思路：修改传入hash的值 12value肯定与成绩相关hash(value) 那value具体是怎么样的呢？通过抓包的数据可以判定为是个h5游戏，在js代码中可能包含相要的答案 在浏览器中打开上面中的game.html验证确实是一个h5游戏： 解决： 用Charles的Mirror功能把抓包的数据自动保存为文件，再在文本编辑器中检查代码 在game.html文件中查找rest/game_report，因为有这个网络包，所以先查找这个关键字，结果如下： 123456function _gameReport(score, callBack, hash, time)&#123; var oAjax = null; //这里进行HTTP请求 oAjax = new XMLHttpRequest(); oAjax.open(&apos;post&apos;,HOSTURLAPI+&quot;/rest/game_report&quot;+&quot;?uid=&quot;+UID+&quot;&amp;gameid=&quot;+GAMEID+&quot;&amp;score=&quot;+score+&quot;&amp;tm=&quot;+time+&quot;&amp;hash=&quot;+hash,true);&#125; 查找_gameReport函数的调用者 1234567891011function gameReport(score, callBack)&#123; var timeData = new Date().getTime(); var hashValue = UID+GAMEID+score+timeData; var hash = &apos;&apos;; dsBridge.call(&apos;hashCode&apos;,hashValue,function(data)&#123; hash = data; _gameReport(score, callBack, hash, timeData); &#125;);&#125;gameReport(b[0], function(success, old_score)&#123;&#125;) js代码调用到App的hashCode方法，hashValue = UID+GAMEID+score+timeData用Charles的Rewrite功能Body替换： 12345Match Value:gameReport(b[0]Replace Value:gameReport(&apos;99&apos; 成绩已修改，hash验证已通过 Mirror应用文档：https://www.charlesproxy.com/documentation/tools/mirror/ The Mirror tool saves responses to disk as they are received, creating a mirror copy of websites as you browse them. Mirror把响应保存为文件到硬盘上 No Caching 和 Block Cookies应用在案例：扶我起来学数学App的伪装者游戏通过Rewrite功能修改了js文件中的内容；但有时js文件不是每次都会传输，而是使用了缓存，这时Rewrite功能就失效了，因为没有发生网络请求；通过No Caching 和 Block Cookies使网络请求每次都发生 Map Local应用 Map Local应用场景 修改js文件来改变App行为: 1. 使用No Caching 和 Block Cookies功能保证js文件通过网络请求加载到App 2. 使用Mirror功能把js文件保存到电脑上 3. 使用Map Local功能使App加载修改后的js文件]]></content>
      <tags>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mitmproxy的使用]]></title>
    <url>%2F2019%2F09%2F28%2Fmitmproxy%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC]mitmproxy的使用mitmproxy is a free and open source interactive HTTPS proxy.官网：https://mitmproxy.org/安装：pip3 install mitmproxy 或 brew install mitmproxy安装后有3个命令行工具：mitmproxy, mitmdump, mitmweb 这里不介绍mitmweb的使用，mitmproxy与mitmdump的功能重点：mitmproxy：交互式；查看流量数据(请求与响应)；执行自定义脚本mitmdump：执行自定义脚本，脚本在Mitmproxy中叫做Addon 使用mitmproxy：因为是命令行界面，所以需要记住一些快捷键使用mitmdump：偏向编写python代码 通过一个典型的调用，来认识下Mitmproxy下的核心概念： 1➜ ~ mitmproxy --set scripts=ad_short_mitm.py &apos;~u baidu\.com&apos; 在Mitmproxy的叫法 set Command scripts Options ad_short_mitm.py Addon ‘~u baidu\.com’ Filter expressions mitmproxy1➜ ~ mitmproxy 输入上面命令，启动mitmproxy并显示Flows界面： Flows界面 快捷键 第1个也是最重要的快捷键：?: 进入Help界面： 进入Help界面 第2个重要的快捷键：:: Command prompt,进入命令输入模式 进入命令输入模式 可以输入的命令：可以在Command Reference界面查看 可以按tab来命令补全：比如输入flow.m；再按tab; 补全为flow.mark 可以按tab来路径补全 按enter执行命令 常用的命令可以用快捷键，不用进入命令输入模式，省去输入的时间 界面间跳转快捷键 快捷键 界面 截图 ? Help界面 K Key Bindings界面 P Flow Details界面 E Events界面 C Command Reference界面 O Options界面 注意：上面的快捷键，都是大写字母，mitmproxy的快捷键是区分大小写的 Flows界面居然没有快捷键？ 导航快捷键 快捷键 command 说明 q console.view.pop 返回：界面间的返回 g console.nav.start 跳到第一行 G console.nav.end 跳到最后一行 h console.nav.left j console.nav.down 跳到下一行 k console.nav.up 跳到上一行 l console.nav.right space console.nav.pagedown ctrl b console.nav.pageup ctrl f console.nav.pagedown tab console.nav.next g\G\j\k等这样的导航键是通用的：在Flows、Events、Command、Options等界面都能用 刚开始学命令行界面时，有这么命令、快捷键要记，没记住怎么办？这里介绍下mitmproxy的--no-server, -n应用 123456➜ ~ mitmproxy --helpusage: mitmproxy [options]...Proxy Options: --no-server, -n --server Start a proxy server. Enabled by default. 第1个Terminal窗口里正常启动mitmproxy：➜ ~ mitmproxy 开启第2个Terminal窗口带--no-server选项启动mitmproxy：➜ ~ mitmproxy --no-server；按K/C/O/?查看快捷键、Command、Options、帮助 第2个mitmproxy专门用于查看快捷键、Command、Options、帮助 案例实战以东方头条App - 幸运大转盘这个游戏为实战 东方头条App - 幸运大转盘 1.点击’领取金币’：会发出https://…/zhuanpan/get_zhuanpan_new网络请求 2.点击’立即领取’：会发出https://…/zhuanpan/get_gold网络请求 应用目的：通过mitmproxy的replay功能来减少手动操作时间知识点：Filter expressions, Options, Command 1.启动mitmproxy 1➜ ~ mitmproxy 2.点开东方头条App到幸运大转盘界面 3.点击’领取金币’；点击’立即领取’； 问题：这时候mitmrpoxy的Flow界面已包含上面的网络请求，网络请求非常多，怎么找到需要的请求 解答：应用mitmrpoxy的Filter expressions 4.按f快捷键：设置view_filter这个Option 按f快捷键, 设置view_filter * 5.输入~u zhuanpan, 按回车执行命令 输入~u zhuanpan 知识点：~u zhuanpan是Filter expressions：~u regex，用来过滤URL符合regex正则表达式的网络请求；可以按？跳转到Help界面查看全部的Filter expressions 6.用j导航快捷键定位到zhuanpan/get_zhuanpan_new网络请求；按下m快捷键将这条网络请求标记 按下m标记网络请求 7.用同样的操作，标记zhuanpan/get_gold网络请求 按下m标记网络请求 8.按:快捷键, 进入命令输入模式；输入rep, 按tab补全命令; 输入@marked; 按回车执行命令 按tab补全命令 出于演示使用mitmrpoxy的目的，才增加了许多不必要的步骤；简洁方法： 去除步骤4、5、6、7 步骤8改为: replay.client &quot;(~u zhuanpan/get_zhuanpan_new) | (~u zhuanpan/get_gold)&quot; 案例到此结束，小结下用到的快捷键、命令： 快捷键 command 说明 f : set view_fliter= 只显示符合条件的网络请求 m flow.mark.toggle @focus Toggle mark on this flow : replay.client @marked 重放多条标记的网络请求 相关快捷键： 快捷键 界面 command 说明 M flowlist view.marked.toggle Toggle viewing marked flows U flowlist flow.mark @all false Un-set all marks r flowlist replay.client @focus Replay this flow 一些用到Filter expressions的Options:view_filter、save_stream_filter、intercept 相关文档：https://docs.mitmproxy.org/stable/concepts-options/https://docs.mitmproxy.org/stable/concepts-filters/ 问题上面的实战有以下几个问题： 第1次收集操作时，不是每次都抽到金币，也有可能抽到广告；怎样每次都跳过广告？ 游戏有20次机会，要手动输入多次replay.client @marked才能把20次机会用完；怎样才能减少手动操作？ 这些问题我们通过编写脚本来解决。这里使用mitmproxy的其它功能为编写脚本提供方便把实战的已被标记的2个网络请求保存为文件，方便查看： 快捷键 界面 command 说明 w flowlist console.command save.file @shown Save listed flows to file 1.按w快捷键, 把@shown修改为@marked; 指定保存路径；按回车执行命令 按w保存为文件 输入路径时，可以按tab来补全路径 最好不要使用~：像我自己Mac上输入~/zhuanpan.mitm，没有保存成功；当然你也可以测试下使用~的路径能否保存成功 输入的文件的后缀名是可以随意指定的；保存的文件为二进制格式 2.开启第2个Terminal窗口带–no-server选项启动mitmproxy 1➜ ~ mitmproxy --no-server 快捷键 界面 command 说明 L flowlist console.command view.load Load flows from file 3.按L快捷键, 把步骤1保存的文件加载进来 按L加载文件 好了，编写脚本的准备工作结束！小结下用到的快捷键、命令： 快捷键 界面 command 说明 w flowlist console.command save.file @shown Save listed flows to file L flowlist console.command view.load Load flows from file 相关快捷键： 快捷键 界面 command 说明 e flowlist console.command export.file {choice} @focus Export this flow to file 快捷键w与e的区别 w e 文件为二进制文件 文件为文本文件 保存的信息完整 只保存请求信息，不保存响应信息 能一次保存多条网络请求信息 一次只能保存一条网络请求信息 mitmdumpMitmproxy是用python实现的，编写相应的Addon脚本也是用python shell脚本先用在mitmproxy的e快捷键来辅助编写shell脚本，来解决下上面的实战问题 用e快捷键分别保存zhuanpan/get_zhuanpan_new、zhuanpan/get_gold网络请求为文件get_zhuanpan_new.sh、get_gold.sh get_zhuanpan_new.sh文件内容：[get_gold.sh内容类似，不再列出] 1curl -H &apos;Host:zhuanpan.dftoutiao.com&apos; -H &apos;Content-Type:application/x-www-form-urlencoded&apos; -H &apos;Connection:keep-alive&apos; -H &apos;Accept:*/*&apos; -H &apos;User-Agent:DFTT/2.4.8 (iPhone; iOS 12.3.1; Scale/3.00)&apos; -H &apos;Accept-Language:zh-Hans-CN;q=1, en-CN;q=0.9, zh-Hant-CN;q=0.8&apos; -H &apos;Content-Length:484&apos; -H &apos;Accept-Encoding:br, gzip, deflate&apos; -X POST &apos;https://zhuanpan.dftoutiao.com/zhuanpan/get_zhuanpan_new&apos; --data-binary &apos;accid=834536089&amp;appqid=AppStore190602&amp;apptypeid=DFTT&amp;appver=2.4.8&amp;device=iPhone%206s%20Plus%20%28A1634/A1687%29&amp;deviceid=AE9418A1-561A-4F5C-AF05-1EC222A50CF3&amp;fr=rwzx&amp;ime=F2B14555-E2EB-4556-B757-2C55799C92C2&amp;lt=d2RlWExGb015UjRqSkxMZk0rRkYwcTAzd0I3RmErMWRLbzZsYTc4dkFtakxLMmgvdW9xWFhYUEFNdU9XTHZMV3F6cWNhVXRPalBSMkJNUHlvTktRbnc9PQ%3D%3D&amp;network=wifi&amp;num=57&amp;os=iOS%2012.3.1&amp;position=%E6%B5%99%E6%B1%9F&amp;sign=5aac4e159e8d205c084c9f9e6cf4e41f&amp;softname=DFTTIOS&amp;softtype=TouTiao&amp;ts=1564368354&apos; 把get_zhuanpan_new.sh、get_gold.sh的内容合并到最终的文件中zhuanpan.sh 123456789101112131415#!/usr/bin/env bashfunction zhuanpan&#123; # mitmproxy用快捷键e导出的get_zhuanpan_new.sh文件内容原样写到这 curl -H 'Host:zhuanpan.dftoutiao.com' -H 'Content-Type:application/x-www-form-urlencoded' -H 'Connection:keep-alive' -H 'Accept:*/*' -H 'User-Agent:DFTT/2.4.8 (iPhone; iOS 12.3.1; Scale/3.00)' -H 'Accept-Language:zh-Hans-CN;q=1, en-CN;q=0.9, zh-Hant-CN;q=0.8' -H 'Content-Length:484' -H 'Accept-Encoding:br, gzip, deflate' -X POST 'https://zhuanpan.dftoutiao.com/zhuanpan/get_zhuanpan_new' --data-binary 'accid=834536089&amp;appqid=AppStore190602&amp;apptypeid=DFTT&amp;appver=2.4.8&amp;device=iPhone%206s%20Plus%20%28A1634/A1687%29&amp;deviceid=AE9418A1-561A-4F5C-AF05-1EC222A50CF3&amp;fr=rwzx&amp;ime=F2B14555-E2EB-4556-B757-2C55799C92C2&amp;lt=d2RlWExGb015UjRqSkxMZk0rRkYwcTAzd0I3RmErMWRLbzZsYTc4dkFtakxLMmgvdW9xWFhYUEFNdU9XTHZMV3F6cWNhVXRPalBSMkJNUHlvTktRbnc9PQ%3D%3D&amp;network=wifi&amp;num=57&amp;os=iOS%2012.3.1&amp;position=%E6%B5%99%E6%B1%9F&amp;sign=5aac4e159e8d205c084c9f9e6cf4e41f&amp;softname=DFTTIOS&amp;softtype=TouTiao&amp;ts=1564368354' # mitmproxy用快捷键e导出的get_gold.sh文件内容原样写到这 curl -H 'Host:zhuanpan.dftoutiao.com' -H 'Content-Type:application/x-www-form-urlencoded' -H 'Connection:keep-alive' -H 'Accept:*/*' -H 'User-Agent:DFTT/2.4.8 (iPhone; iOS 12.3.1; Scale/3.00)' -H 'Accept-Language:zh-Hans-CN;q=1, en-CN;q=0.9, zh-Hant-CN;q=0.8' -H 'Content-Length:487' -H 'Accept-Encoding:br, gzip, deflate' -X POST 'https://zhuanpan.dftoutiao.com/zhuanpan/get_gold' --data-binary 'accid=834536089&amp;appqid=AppStore190602&amp;apptypeid=DFTT&amp;appver=2.4.8&amp;device=iPhone%206s%20Plus%20%28A1634/A1687%29&amp;deviceid=AE9418A1-561A-4F5C-AF05-1EC222A50CF3&amp;fr=rwzx&amp;ime=F2B14555-E2EB-4556-B757-2C55799C92C2&amp;isfirst=0&amp;lt=d2RlWExGb015UjRqSkxMZk0rRkYwcTAzd0I3RmErMWRLbzZsYTc4dkFtakxLMmgvdW9xWFhYUEFNdU9XTHZMV3F6cWNhVXRPalBSMkJNUHlvTktRbnc9PQ%3D%3D&amp;network=wifi&amp;os=iOS%2012.3.1&amp;position=%E6%B5%99%E6%B1%9F&amp;sign=c6f61f80d1c001ac5382ef73632e0e9e&amp;softname=DFTTIOS&amp;softtype=TouTiao&amp;ts=1564368376'&#125;for ((i=0; i&lt;20; i++));do zhuanpandone ok，shell脚本以编写完成 python脚本关于Addon的概念可以查看：https://docs.mitmproxy.org/stable/addons-overview/ 编写Addon脚本写些什么呢？先上一下模板： 12345678910111213141516171819202122from mitmproxy import ctxfrom mitmproxy import flowfilterfrom mitmproxy import httpfrom mitmproxy import addonmanagerclass Myaddon(object): def __init__(self): pass def load(self, entry: addonmanager.Loader): pass def request(self, flow: http.HTTPFlow): pass def response(self, flow: http.HTTPFlow): passaddons = [ Myaddon()] 编写Addon脚本:就是选择性的实现上面的方法 具体都有哪些方法可以选择性实现，可以查看如下文档： 文档 https://docs.mitmproxy.org/stable/addons-events/ 源代码 docs/src/examples/addons/events.py 源代码 mitmproxy/eventsequence.py 开始实现Addon脚本： 新建文件zhuangpan_mitm.py, 实现__init__方法： 12345678910111213141516171819import jsonimport refrom mitmproxy import ctxfrom mitmproxy import flowfilterfrom mitmproxy import httpclass Zhuangpan(object): def __init__(self): self.filter = flowfilter.parse(r&apos;(~u zhuanpan/get_zhuanpan_new) | (~u zhuanpan/get_gold)&apos;) self.new_fliter = flowfilter.parse(r&apos;~u zhuanpan/get_zhuanpan_new&apos;) self.get_fliter = flowfilter.parse(r&apos;~u zhuanpan/get_gold&apos;) self.flows = [] self.urls = set() self.remain = 0addons = [ Zhuangpan()] 这里用到了Mitmproxy的api:flowfilter.parse： 12345678910# mitmproxy/flowfilter.py文件def parse(s: str) -&gt; TFilter:# 还定义了：def match(flt, flow): &quot;&quot;&quot; Matches a flow against a compiled filter expression. Returns True if matched, False if not. .... &quot;&quot;&quot; 实现request方法： 123456789class Zhuangpan(object): ... def request(self, flow: http.HTTPFlow): if flowfilter.match(self.filter, flow): url = flow.request.url if not url in self.urls: ctx.log.alert(url) self.flows.append(flow) self.urls.add(url) 实现response方法： 123456789101112131415class Zhuangpan(object): ... def response(self, flow: http.HTTPFlow): if flowfilter.match(self.new_fliter, flow): flow.response.replace(r&apos;&quot;gold&quot;:0&apos;, &apos;&quot;gold&quot;:999&apos;) text = flow.response.text data = json.loads(text) self.remain = data.get(&apos;data&apos;).get(&apos;cur_num&apos;) ctx.log.alert(&apos;remain count:&#123;&#125;&apos;.format(self.remain)) if flowfilter.match(self.get_fliter, flow): if self.remain &gt; 0 and len(self.urls) &gt;= 2: flows = [f.copy() for f in self.flows] ctx.master.commands.call(&quot;replay.client&quot;, flows) 使用ctx.log.xxx等方法来代替使用print或logging.warning等方法： 在mitmproxy中，ctx.log.xxx记录的信息会出现在Event界面, 而其它方法不会出现在Event界面 在mitmdump中，ctx.log.xxx记录的信息事件显示的顺序正确, 而其它方法显示的顺序不正确 使用123456➜ ~ mitmdump --scripts zhuangpan_mitm.pyLoading script zhuangpan_mitm.pyProxy server listening at http://*:8080 # --scripts SCRIPT, -s SCRIPT Execute a script. May be passed multiple times. 12345678mitmdump --set userid=zhj -s &quot;mitm_user_xxx.py&quot; -s math_mitm.py &apos;~u mapi.hddgood.com&apos;mitmdump --set replacements=&apos;/~s/&quot;video_url&quot;:&quot;(.+)&quot;&#125;/&quot;video_url&quot;:&quot;https://vd3.bdstatic.com/abc.mp4&quot;&#125;&apos;# 代码里可以调用ctx.master.commands.call(&quot;replay.client&quot;, [flow])ctx.master.commands.execute(&quot;view.focus.go 0&quot;) 其它问题：只关注某个域名下的流量，怎么设置？解决：ignore_hostshttps://docs.mitmproxy.org/stable/howto-ignoredomains/ 123456# Ignore everything but example.com and mitmproxy.org:--ignore-hosts &apos;^(?!example\.com)(?!mitmproxy\.org)&apos;正则表达式：反前瞻反前瞻：要匹配某个模式时，需要在它 后面找不到含有给定前瞻模式的内容foo(?!bar) Negative lookahead assertion. The pattern foo will only match if not followed by a match of pattern bar. 代码阅读源码地址：https://github.com/mitmproxy/mitmproxy mitmproxy/tools/_main.py 123456789101112131415161718192021222324252627282930313233343536373839404142入口方法：def mitmproxy(args=None) -&gt; typing.Optional[int]: run(console.master.ConsoleMaster)def mitmdump(args=None) -&gt; typing.Optional[int]: run(dump.DumpMaster) 主要代码def run(master_cls): opts = options.Options() master = master_cls(opts) pconf = proxy.config.ProxyConfig(opts) server = proxy.server.ProxyServer(pconf) master.server = server master.run() return master master.Master console.master.ConsoleMaster dump.DumpMaster web.master.WebMasterServer proxy.server.ProxyServer proxy.server.DummyServerMaster与Server关系： master.server = serverMaster和Server对象生成： Master(opts: options.Options) Server(config: config.ProxyConfig)ProxyConfig与Options关系： ProxyConfig(options: options.Options) 123456789101112131415161718开始运行： master.run() master.start() def start(self): if self.server: ServerThread(self.server).start()class ServerThread(basethread.BaseThread): def __init__(self, server): self.server = server address = getattr(self.server, &quot;address&quot;, None) super().__init__( &quot;ServerThread (&#123;&#125;)&quot;.format(repr(address)) ) def run(self): self.server.serve_forever() 12345678910111213141516171819202122232425262728293031323334353637383940线程： ServerThread connection_thread def connection_thread(self, connection, client_address): with self.handler_counter: try: self.handle_client_connection(connection, client_address) finally: close_socket(connection) def handle_client_connection(self, conn, client_address): h = ConnectionHandler( conn, client_address, self.config, self.channel ) h.handle() def handle(self): self.log(&quot;clientconnect&quot;, &quot;info&quot;) root_layer = None root_layer = self._create_root_layer() root_layer = self.channel.ask(&quot;clientconnect&quot;, root_layer) root_layer() self.log(&quot;clientdisconnect&quot;, &quot;info&quot;) def _create_root_layer(self): root_ctx = ... mode = self.config.options.mode if mode.startswith(&quot;upstream:&quot;): return modes.HttpUpstreamProxy elif mode == &quot;transparent&quot;: return modes.TransparentProxy(root_ctx) elif mode == &quot;regular&quot;: return modes.HttpProxy(root_ctx) 123456789101112131415161718192021222324252627282930313233343536373839addons的运行过程[生命周期][1]. &quot;load&quot;[2]. &quot;running&quot;[3]. &quot;configure&quot;[1]. &quot;load&quot;DumpMaster.__init__(self,options): super().__init__(options) self.addons.add(*addons.default_addons())AddonManager.add(self, *addons): for i in addons: self.chain.append(self.register(i)) AddonManager.register(self, addon): l = Loader(self.master) self.invoke_addon(addon, &quot;load&quot;, l) [2]. &quot;running&quot;master.run(): loop = asyncio.get_event_loop() self.run_loop(loop.run_forever) master.run_loop(self, loop): asyncio.ensure_future(self.running()) master.running(self): self.addons.trigger(&quot;running&quot;) [3]. &quot;configure&quot;class AddonManager: def __init__(self, master): self.lookup = &#123;&#125; self.chain = [] self.master = master master.options.changed.connect(self._configure_all) def _configure_all(self, options, updated): self.trigger(&quot;configure&quot;, updated) 参考https://stackoverflow.com/questions/51893788/using-mitmproxy-inside-python-script https://dev.to/kevcui/3-mitmproxy-tips-you-might-not-know-about-5dbg https://github.com/KevCui/mitm-scripts]]></content>
      <tags>
        <tag>mitmproxy</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS快速设置代理]]></title>
    <url>%2F2019%2F09%2F27%2Fios-switch-proxy%2F</url>
    <content type="text"><![CDATA[问题手动设置wifi的步骤非常长： 点击“设置” 点击“无线局域网” 点击已连接的wifi 点击“配置代理” 点击“手动” 定位服务器输入框，输入ip 定位端口输入框，输入port 点击“存储” 解决用iOS上的Shadowrocket和Mac上的Charles来快速设置代理iOS和Mac在同一wifi 启动Charles，假设代理地址为：192.168.0.100:8888 Shadowrocket设置全局路由为代理 Shadowrocket添加HTTP类型的节点 Shadowrocket打开连接 添加HTTP类型的节点: 结果:]]></content>
      <tags>
        <tag>代理</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的阅读列表]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%88%91%E7%9A%84%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基础 汇编语言入门教程 理解字节序 正则表达式30分钟入门教程 YAML 语言教程 理解OAuth 2.0 基于python flask详述 OAuth 2.0 的运作流程 RESTful API 最佳实践 算法 《我的第一本算法书》 极客时间-数据结构与算法之美 极客时间-算法面试通关40讲 网络 极客时间-趣谈网络协议 《Wireshark网络分析就这么简单》 《Wireshark网络抓包从入门到熟练》 The First Few Milliseconds of an HTTPS Connection 为什么Wireshark无法解密HTTPS数据 curl 的用法指南 curl 网站开发指南 使用 curl 命令分析请求的耗时情况 在Linux中使用curl命令参数详解 协议 WebSocket 教程 SSH原理与运用（一）：远程登录 SSH原理与运用（二）：远程登录 SSH 技巧 ssh密钥对登录安全吗？原理篇 针对不同主机使用不同 SSH Key JavaScript ECMAScript 6 入门 前端基础进阶系列 JavaScript深入系列 iOS iOS阅读列表 Python Python阅读列表 Node.js Node Cookbook Second Edition 深入浅出Node.js 前端 Flask Web开发：基于Python的Web应用开发实战 Front-End Web Development The Big Nerd Ranch Guide Handlebars模板引擎 Shell xargs 命令教程 Bash 脚本 set 命令教程 命令行通配符教程 Pro Bash Programming, Second Edition linux命令行精选网 linux常用命令-帮助命令-授之以渔 Printing colors in the terminal Linux linux 网络虚拟化： network namespace 简介 Linux 的启动流程 Systemd 入门教程：命令篇 Systemd 入门教程：实战篇 详解 Linux 下的用户管理、用户组管理和权限管理 Docker 入门教程 图书 编译系统透视 SQL基础教程（第2版） 图解密码技术 深度学习入门：基于Python的理论与实现(英文名：Deep Learning From Scratch) Python深度学习(英文名：Deep Learning With Python) Python3网络爬虫开发实战 精通Scrapy网络爬虫 网站]]></content>
  </entry>
</search>
