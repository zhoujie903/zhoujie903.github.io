<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[趣消除App自动化 - 成语消消乐-全自动化]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%88%90%E8%AF%AD%E6%B6%88%E6%B6%88%E4%B9%90-%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[TOC]趣消除App自动化 - 成语消消乐-全自动化目标趣消除App自动化 - 成语消消乐-半自动化这篇文章实现了成语消消乐的半自动化： 用户点击开始一局游戏 代码自动答题 对代码没有找到的成语，用户自己点击成语赢得游戏 这篇文章的目的是全自动化： 代码自动开始一局游戏 代码自动答题 对没有全部找到的，放弃这局：等待对方赢得游戏； 开始下一局游戏 写在前面： 自己的文章从不介绍背景知识，直接上代码；因为定位实战，非教程 看了些评论，多是不明觉厉，希望你可以评主题相关的讨论或感谢 这篇文章威力巨大[呵呵]，所以不要做恶；不要做恶；不要做恶； 不要做恶：比如游戏有12个成语要找，但代码只答对了11个，还有1个成语4个字，共有4*3*2*1=24种排列组合，请读者不要发24个请求来找到这最后一个成语，这是楼主认为的’做恶’，也是对自动化：对没有全部找到的，放弃这局：等待对方赢得游戏做出的取舍；你可以用游戏里的认输和提示 写这篇文章与代码的目的： 虚荣：有读者阅读、评论 金钱：赢得游戏有几分钱 时间：游戏里插了很广告，跳过广告；自动化节约自己时间 能力：要写能用的代码，一定要学点什么，比如学习了websocket库 爱惜：自己的手机用了3年了，移植到电脑上来执行，可以让手机再战一年啊 成就：代码和文章等作品；不同维度地’虐人’的快感[鄙视] 好了，希望你找到了学习的兴趣与动力，上代码 测试环境App: 趣消除AppiOS版本、扶我起来学数学AppiOS版本工具: python、Charles、python第三方库websocket背景知识：python、抓包、websocket 解决分析成语消消乐有2个接口： https://king.hddgood.com/king_api/v1/game/join_game[http] wss://king.hddgood.com/websock_m/websock_message?uid={}&amp;gameid={}&amp;token={}[websocket] game/join_game接口会返回websock_m/websock_message接口需要的gameid；gameid每局都不同 uid对每个账号是固定 token对一次登入是固定，每局游戏都一样； 游戏的消息来回传递都在websock_m/websock_message接口websocket协议里完成 123456POST /king_api/v1/game/join_game HTTP/1.1Host: king.hddgood.comA-Token-Header: PTtWUFdWUkBFHEVZCVcNdUtVWwdc=Cookie: UM_distinctid=16b27e625da1ef-038c4847dc733-336d7451-4a640-16b27e625dd490; cn_1276022107_dplus=%7B%22distinct_id%22%3A%20%2216b27e625da1ef-038c4847dc733-336d7451-4a640-16b27e625dd490%22%2C%22%24_sessionid%22%3A%20104%2C%22%24_sessionTime%22%3A%201561087099%2C%22%24dp%22%3A%200%2C%22%24_sessionPVTime%22%3A%201561087099%2C%22initial_view_time%22%3A%20%221559738991%22%2C%22initial_referrer%22%3A%20%22%24direct%22%2C%22initial_referrer_domain%22%3A%20%22%24direct%22%2C%22%24recent_outside_referrer%22%3A%20%22%24direct%22%7D; CNZZDATA1276022107=326225286-1559738991-%7C1561086230uid=1457362&amp;rank=11&amp;type=G 12345HTTP/1.1 200 Content-Type: application/json;charset=UTF-8Connection: close&#123;&quot;success&quot;:true,&quot;msg&quot;:&quot;操作成功&quot;,&quot;code&quot;:&quot;200&quot;,&quot;codemsg&quot;:&quot;操作成功&quot;,&quot;result&quot;:&#123;&quot;gameid&quot;:&quot;G11-810737&quot;,&quot;dup&quot;:0,&quot;starter&quot;:472251&#125;&#125; 工作原理写2个文件：chengyu-auto.py[代码文件]、chengyu.text[数据文件] chengyu-auto.py从asking消息里解析出ask_string到chengyu.text文件里查找是否包含相应的成语 自动提交成语答案 chengyu.text文件刚开始是空的；在每局游戏结束时，游戏都会发送game_result消息给我们，里面有这局游戏的答案成语，把这些成语写到文件中 玩的局数越多，chengyu.text文件包含的成语越多，查找到答案的可能性越大 代码需要安装第三方python库：websocketschengyu-auto.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421#!/usr/bin/env python3# coding=utf-8'''# 趣消除App-成语消消乐全自动化；# App版本：1.1.2# App地址：https://itunes.apple.com/cn/app/id1449545954提现非常迅速'''import reimport timeimport datetimeimport randomimport jsonimport sysimport loggingimport collectionsimport pathlibimport requestsRed = '\033[0;31m'Green = '\033[0;32m'Yellow = '\033[0;33m' Blue = '\033[0;34m'Purple = '\033[0;35m' Cyan = '\033[0;36m' White = '\033[0;37m' colors = &#123; 0:Red, 1:Purple, 2:Yellow, 3:Blue, 4:White,&#125;# 这些变量的值可以通过像Charles抓包软件获得# 账号变量# ------------------------------------------------# A_Token_Header的一些结论：# 1.每个账号不同；# 2.同一个账号每次登录时也是不一样的# 3.同一个账号，退出时，只要不登录，上次的A-Token-Header的值还有效，只有再登录时，上次的token值才失败A_Token_Header_zxg = 'PTtWUFdWUkBFHEVZCVcNdUtVWwdc'# Cookie的一些结论：# 1.同一个账号，退出或再登录，都不用修改，一直有效# 2.值为空也可以Cookie_zxg = ''# UUID的一些结论：# 1.固定不变UUID_zxg = '1457362'# ------------------------------------------------api_ = 'https://king.hddgood.com/king_api/v1/'class QuXiaoChuUser(): headers = &#123; 'Host': 'king.hddgood.com', 'Accept': 'application/json, text/plain, */*', 'Accept-Language': 'zh-cn', 'Origin': 'https://king.hddgood.com', 'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 12_1_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/16D57/; quxiaochu/ios v1.1.2', 'Referer': 'https://king.hddgood.com/' &#125; data = &#123; 'uid': '', 'channel': '', 'version': '1.1.2', 'os': 'ios', 'web_ver': '20190261' &#125; SLEEP = 0.5 def __init__(self, uid, token_header, cookie): self.uid = uid self.headers = dict(QuXiaoChuUser.headers) self.headers['A-Token-Header'] = token_header self.token_header = token_header self.headers['Cookie'] = cookie def game_chengyu_join_game(self, rank): ''' 成语消消乐-获取游戏id https://king.hddgood.com/king_api/v1/game/join_game &#123;"success":true,"msg":"操作成功","code":"200","codemsg":"操作成功","result":&#123;"gameid":"G15-3232777","dup":0,"starter":531492&#125;&#125; ''' print("成语消消乐-获取游戏id &#123;&#125;".format(self.uid)) data = self._uid_data() # 1:书童；2:儒生；15:殿阁大学士 data['rank'] = str(rank) data['type'] = 'G' api = self._genapi('game/join_game') result = self._post(api, self.headers, data) return json.loads(result) def _uid_data(self): return &#123;'uid': self.uid&#125; @staticmethod def _genapi(path): return 'https://king.hddgood.com/king_api/v1/' + path @staticmethod def _post(api, headers, data, p=logging.warning): time.sleep(QuXiaoChuUser.SLEEP) res = requests.post(api, headers=headers, data=data, verify=False) print(res.url) result = res.text print(result) print('') return resultclass Chengyu(object): def __init__(self): path = pathlib.PurePath(__file__) path = path.parent.joinpath('chengyu.text') self.dictpath = str(path) self.chengyu = set() with open(self.dictpath, 'rt') as f: for line in f.readlines(): self.chengyu.add(line.strip()) self.answers = list() self.ask_string = '' # &#123;'和':[1,8], '我':[11]&#125; self.char_indexs_dict = dict() # &#123;1:'和', 8:'和', 11:'我'&#125; self.index_char_dict = dict() self.count = 0 # 自动提交答案的网络发送次数 self.auto_send_answers = list() self.ack_true_answers = list() # 找到的的成语中各异字符为2个的答案数量：如 [真真假假] self.answer_2chars_count = 0 # &#123;'中流砥柱':[1,9,21,25]&#125; self.answer_indexs_dict = dict() # &#123;'中流砥柱':set('中流砥柱')&#125; self.answer_charset_dict = dict() # 查找到的错误答案 self.error_answers = [] # --------------------------------------------- def find_answers_v2(self, ask_string): ''' 在内存成语字典查找答案 ''' ask_set = set(ask_string) for i, c in enumerate(ask_string): self.char_indexs_dict.setdefault(c, []).append(i) self.index_char_dict = dict( zip(range(len(ask_string)), ask_string)) max_count = (len(ask_string) / 4 ) * 1.5 for item in self.chengyu: item_set = self.answer_charset_dict.setdefault(item, set(item)) if not (item_set - ask_set): self.answers.append(item) if len(item_set)&lt;4: self.answer_2chars_count += 1 if len(self.answers) - self.answer_2chars_count &gt;= max_count : self.count = len(self.answers) return self.count = len(self.answers) async def auto_answer(self, flow): if len(self.answers): item = self.answers[0] answer_index = [] counter = collections.Counter(item) for char, count in counter.items(): if self.char_indexs_dict[char]: if len(self.char_indexs_dict[char]) &lt; count: self.error_answers.append(item) self.answers.remove(item) return else: pass for c in item: if self.char_indexs_dict[c]: index = self.char_indexs_dict[c][0] answer_index.append( str(index) ) del self.char_indexs_dict[c][0] else: pass if len(set(answer_index)) &lt; 4: print('算法有错误：&#123;&#125; 小于4'.format(answer_index)) send_message = &#123; 'answer': item, 'answer_index': answer_index, 'type': 'answer' &#125; mm = json.dumps(send_message) # ----------------------- print(mm) # ----------------------- self.answer_indexs_dict[item] = answer_index # 向服务器发送消息 self.auto_send_answers.append(item) self.answers.remove(item) await flow.send(mm) # time.sleep(0.5) def add_new_worlds_to_memory(self, m): ''' 把答案增加到内存字典中 ''' if len(self.ack_true_answers) &lt; len(m['all_answer']): for answer in m['all_answer']: self.chengyu.add(answer['phrase']) print('\033[1;31m 共收录&#123;&#125;个成语 \033[0m'.format(len(self.chengyu))) def add_new_worlds_to_file(self, m): ''' 把答案增加到文件中 ''' if len(self.ack_true_answers) &lt; len(m['all_answer']): with open(self.dictpath, 'wt') as f: l = list(self.chengyu) l.sort() for item in l: f.write(item) f.write('\n') def print_answers(self): ''' 图形化、色彩化显示答案 ''' self.print_color('共找到 &#123;&#125;/&#123;&#125; 个成语'.format(self.count, len(self.ask_string)//4)) self.print_color('错误成语 &#123;&#125;'.format(self.error_answers)) self.print_color('共自动 &#123;&#125; 次提交：&#123;&#125;'.format(len(self.auto_send_answers),self.auto_send_answers)) self.print_color('已确认 &#123;&#125; 个提交：&#123;&#125;'.format(len(self.ack_true_answers),self.ack_true_answers)) self.print_color('问题 &#123;&#125;'.format(self.ask_string)) for item in self.answers: self.print_color(item) # self.print_matrix(item) if (not self.answers) and self.index_char_dict: self.print_matrix() def print_matrix(self, item = []): chars_in_line = 6 length = len(self.ask_string) lines = (length + chars_in_line - 1) // chars_in_line PADDING = ' '*(lines * chars_in_line - length) is_need_padding = len(PADDING) != 0 self.print_color('--'*chars_in_line) global colors, White for i, c in self.index_char_dict.items(): end = '' if (i+1) % chars_in_line == 0 or (i+1) == length: end = '\n' color = White if c in item: color = colors[item.index(c)] line, first = divmod(i, chars_in_line) if is_need_padding and first == 0 and (line + 1 == lines): c = PADDING + c self.print_color(c, end=end, color=color) self.print_color('--'*chars_in_line) def print_color(self, message, end='\n', color=Red): print('&#123;&#125;&#123;&#125;\033[0m'.format(color, message), end=end) def reset_data_to_init(self): self.ask_string = '' self.answers.clear() self.index_char_dict.clear() self.count = 0 self.answer_2chars_count = 0 self.answer_indexs_dict.clear() self.char_indexs_dict.clear() self.error_answers.clear() self.ack_true_answers.clear() self.auto_send_answers.clear()def chengyu_auto_answer(user: QuXiaoChuUser): ''' 成语消消乐自动答题 wss://king.hddgood.com/websock_m/websock_message?uid=472251&amp;gameid=G15-3232777&amp;token=JSdLVVRRV0ZCH0INUlYNchcDUlc= ''' result = user.game_chengyu_join_game(g_rank) if result['success']: gameid = result['result']['gameid'] url = 'wss://king.hddgood.com/websock_m/websock_message?uid=&#123;&#125;&amp;gameid=&#123;&#125;&amp;token=&#123;&#125;' url = url.format(user.uid, gameid, user.token_header) print(url) import asyncio import websockets async def chengyu(): async with websockets.connect(url) as websocket: print('连接成功') global chengyu live = True count = 0 while live: if count % 10 == 0: keeplive = json.dumps(&#123;"type":"keepalive"&#125;) await websocket.send(keeplive) print('send keeplive') # await asyncio.sleep(0.5) count += 1 m = await websocket.recv() print(f"\n&#123;m&#125;\n") m = json.loads(m) message_type = m['type'] if m.get('ask_string'): chengyu.ask_string = m['ask_string'] # 计算答案 chengyu.find_answers_v2(chengyu.ask_string) if message_type == 'answer': chengyu.answer_indexs_dict[m['answer']] = m['answer_index'] # 删除已回答正确的答案 if m.get('ack') == 1: answer = m['answer'] chengyu.ack_true_answers.append(answer) answer_index = chengyu.answer_indexs_dict.get(answer,[]) for i in answer_index: chengyu.index_char_dict[int(i)] = ' ' try: chengyu.answers.remove(m['answer']) except: pass # 自动答题 await chengyu.auto_answer(websocket) # 显示答案 if len(chengyu.ask_string): chengyu.print_answers() if message_type == 'game_result': live = False # 把答案增加到内存字典中 chengyu.add_new_worlds_to_memory(m) chengyu.add_new_worlds_to_file(m) chengyu.reset_data_to_init() # 其它解析 for item in m['scores']: if str(item['uid']) == user.uid: global g_rank g_rank = item['rank'] print('\033[1;31m 获得金币: &#123;&#125; Rank: &#123;&#125;\033[0m'.format(m['coin'], g_rank)) print('\033[1;31m 游戏结束 \033[0m') asyncio.get_event_loop().run_until_complete(chengyu())def genUsers(): yield QuXiaoChuUser(UUID_zxg, A_Token_Header_zxg, Cookie_zxg)g_rank = 15chengyu = Chengyu()if __name__ == "__main__": for user in genUsers(): start_time = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) for _ in range(20): chengyu_auto_answer(user) time.sleep(1) print('开始时间 ', start_time) print('结束时间 ', time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())) chengyu.text 123456789一劳永逸一掷千金一曝十寒一石二鸟一筹莫展一落千丈一衣带水一语破的... 注意：chengyu.text与chengyu-auto.py放在同一目录下chengyu.text收集约1926个成语，98%能找到全部答案 参考 WebSocket 教程 https://pypi.org/project/websockets/ 楼主的趣消除App系列文章 趣消除App自动化 - 签到and作战休息区 趣消除App自动化 - 成语消消乐-半自动化 趣消除App自动化 - 成语消消乐-全自动化]]></content>
  </entry>
  <entry>
    <title><![CDATA[趣消除app自动化-成语消消乐-半自动化]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%88%90%E8%AF%AD%E6%B6%88%E6%B6%88%E4%B9%90-%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[TOC]目标做为一个程序员，已成中年油腻大叔了？那怎么行，来趣消除App、扶我起来学数学App的成语消消乐游戏battle下这里没有作弊一说，只有发挥自己的特长。做为已毕业十几年的人，肯定不是成语容量，而是工作专业技能 – 上代码测试环境App: 趣消除AppiOS版本、扶我起来学数学App版本工具: mitmproxy、python、Charles背景知识：mitmproxy、python、抓包 解决分析游戏界面上呈现的： 网络呈现：游戏是通过websocket协议来传输json格式的字符串，举asking消息如下： 1234567891011121314&#123; &quot;ask_string&quot;: &quot;步不之来疏笔口平去重学青字斟浅之论暗明尊易伐道不云句来刊酌诛才师&quot;, &quot;type&quot;: &quot;asking&quot;, &quot;scores&quot;: [ &#123; &quot;nick&quot;: &quot;吕耀辉&quot;, .... &#125;, &#123; &quot;nick&quot;: &quot;xxxx&quot;, ...... &#125; ]&#125; 成语答案：answer消息 12345678910&#123; &quot;answer&quot;: &quot;口诛笔伐&quot;, &quot;answer_index&quot;: [ &quot;6&quot;, &quot;29&quot;, &quot;5&quot;, &quot;21&quot; ], &quot;type&quot;: &quot;answer&quot;&#125; 目的是把上面的&quot;ask_string&quot;: &quot;步不之来疏笔口平去重学青字斟浅之论暗明尊易伐道不云句来刊酌诛才师&quot;解析为一个个成语 工作原理写2个文件：chengyu_mitm.py[代码文件]、chengyu.text[数据文件] chengyu_mitm.py从asking消息里解析出ask_string到chengyu.text文件里查找是否包含相应的成语 如果包含成语，图形化、格式化显示结果 chengyu.text文件刚开始是空的；在每局游戏结束时，游戏都会发送game_result消息给我们，里面有这局游戏的答案成语，把这些成语写到文件中 玩的局数越多，chengyu.text文件包含的成语越多，查找到答案的可能性越大 所以我们只要关注：asking消息、game_result消息如果要程序回复答案，可以关注下answer消息[客户端发给服务器的] 代码chengyu_mitm.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287import jsonimport timefrom mitmproxy import ctx&apos;&apos;&apos;&gt; mitmdump -s chengyu_mitm.py &apos;~u websock_m/websock_message&apos;&apos;&apos;&apos;Red = &apos;\033[0;31m&apos;Green = &apos;\033[0;32m&apos;Yellow = &apos;\033[0;33m&apos; Blue = &apos;\033[0;34m&apos;Purple = &apos;\033[0;35m&apos; Cyan = &apos;\033[0;36m&apos; White = &apos;\033[0;37m&apos; colors = &#123; 0:Red, 1:Purple, 2:Yellow, 3:Blue, 4:White,&#125;class Chengyu(object): def __init__(self): self.dictpath = &apos;/Users/zhoujie/chengyu.text&apos; self.chengyu = set() with open(self.dictpath, &apos;rt&apos;) as f: for line in f.readlines(): self.chengyu.add(line.strip()) self.answers = list() self.ask_string = &apos;&apos; # &#123;&apos;和&apos;:[1,8], &apos;我&apos;:[11]&#125; self.char_indexs_dict = dict() # &#123;1:&apos;和&apos;, 8:&apos;和&apos;, 11:&apos;我&apos;&#125; self.index_char_dict = dict() self.count = 0 # 自动提交答案的网络发送次数 self.auto_send_count = 0 # 找到的的成语中各异字符为2个的答案数量：如 [真真假假] self.answer_2chars_count = 0 # &#123;&apos;中流砥柱&apos;:[1,9,21,25]&#125; self.answer_indexs_dict = dict() # self.error_answers = [] # 玩了多少局 self.play_times = 0 # General lifecycle def load(self, loader): ctx.log.info(&apos;\033[1;31mevent: load\033[0m&apos;) def configure(self, updated): ctx.log.info(&apos;\033[1;31mevent: configure\033[0m&apos;) # Websocket lifecycle def websocket_message(self, flow): &quot;&quot;&quot; Called when a WebSocket message is received from the client or server. The most recent message will be flow.messages[-1]. The message is user-modifiable. Currently there are two types of messages, corresponding to the BINARY and TEXT frame types. &quot;&quot;&quot; ctx.log.info(&apos;\033[1;31m websocket_message \033[0m&apos;) # get the latest message message = flow.messages[-1] # simply print the content of the message ctx.log.info(&apos;&apos;) ctx.log.info(message.content) ctx.log.info(&apos;&apos;) m = json.loads(message.content) t = m[&apos;type&apos;] if m.get(&apos;ask_string&apos;): ask_string = m[&apos;ask_string&apos;] self.ask_string = ask_string # 计算答案 self.find_answers_v2(ask_string) self.play_times += 1 if m[&apos;type&apos;] == &apos;answer&apos;: self.answer_indexs_dict[m[&apos;answer&apos;]] = m[&apos;answer_index&apos;] # 删除已回答正确的答案 if m.get(&apos;ack&apos;) == 1: answer = m[&apos;answer&apos;] answer_index = self.answer_indexs_dict.get(answer,[]) for i in answer_index: self.index_char_dict[int(i)] = &apos; &apos; try: self.answers.remove(m[&apos;answer&apos;]) except: pass # 自动答题 self.auto_answer(flow) # 显示答案 self.print_answers() if m[&apos;type&apos;] == &apos;game_result&apos;: # 把答案增加到内存字典中 self.__add_new_worlds_to_memory(m) self.reset_data_to_init() def websocket_end(self, flow): &quot;&quot;&quot; A websocket connection has ended. &quot;&quot;&quot; ctx.log.info(&apos;\033[1;31m websocket_end \033[0m&apos;) self.reset_data_to_init() if self.play_times % 5 == 0: with open(self.dictpath, &apos;wt&apos;) as f: l = list(self.chengyu) l.sort() for item in l: f.write(item) f.write(&apos;\n&apos;) # --------------------------------------------- def find_answers_v2(self, ask_string): &apos;&apos;&apos; 在内存成语字典查找答案 &apos;&apos;&apos; ask_set = set(ask_string) for i, c in enumerate(ask_string): self.char_indexs_dict.setdefault(c, []).append(i) self.index_char_dict = dict( zip(range(len(ask_string)), ask_string)) max_count = len(ask_string) / 4 for item in self.chengyu: item_set = set(item) if not (item_set - ask_set): self.answers.append(item) if len(self.answers) - self.answer_2chars_count &gt;= max_count : self.count = len(self.answers) return self.count = len(self.answers) def auto_answer(self, flow): if len(self.answers): item = self.answers[0] answer_index = [] for c in item: if self.char_indexs_dict[c]: index = self.char_indexs_dict[c][0] answer_index.append( str(index) ) del self.char_indexs_dict[c][0] else: &apos;&apos;&apos; 这个答案是错误的 &apos;&apos;&apos; self.error_answers.append(item) self.answers.remove(item) return ask_string = self.ask_string if len(set(answer_index)) &lt; 4: ctx.log.error(&apos;算法有错误：&#123;&#125; 小于4&apos;.format(answer_index)) send_message = &#123; &apos;answer&apos;: item, &apos;answer_index&apos;: answer_index, &apos;type&apos;: &apos;answer&apos; &#125; mm = json.dumps(send_message) # ----------------------- print(mm) # ----------------------- self.answer_indexs_dict[item] = answer_index # 向服务器发送消息 if not flow.ended and not flow.error: self.auto_send_count += 1 self.answers.remove(item) flow.inject_message(flow.server_conn, mm) time.sleep(0.5) def __add_new_worlds_to_memory(self, m): &apos;&apos;&apos; 把答案增加到内存字典中 &apos;&apos;&apos; for answer in m[&apos;all_answer&apos;]: self.chengyu.add(answer[&apos;phrase&apos;]) ctx.log.info(&apos;\033[1;31m 共收录&#123;&#125;个成语 \033[0m&apos;.format(len(self.chengyu))) def print_answers(self): &apos;&apos;&apos; 图形化、色彩化显示答案 &apos;&apos;&apos; self.print_color(&apos;共找到 &#123;&#125;/&#123;&#125; 个成语&apos;.format(self.count, len(self.ask_string)//4)) self.print_color(&apos;错误成语 &#123;&#125;&apos;.format(self.error_answers)) self.print_color(&apos;共自动 &#123;&#125; 次提交&apos;.format(self.auto_send_count)) for item in self.answers: self.print_color(item) self.print_matrix(item) if (not self.answers) and self.index_char_dict: self.print_matrix() def print_matrix(self, item = []): chars_in_line = 6 length = len(self.ask_string) lines = (length + chars_in_line - 1) // chars_in_line PADDING = &apos; &apos;*(lines * chars_in_line - length) is_need_padding = len(PADDING) != 0 self.print_color(&apos;--&apos;*chars_in_line) global colors, White for i, c in self.index_char_dict.items(): end = &apos;&apos; if (i+1) % chars_in_line == 0 or (i+1) == length: end = &apos;\n&apos; color = White if c in item: color = colors[item.index(c)] line, first = divmod(i, chars_in_line) if is_need_padding and first == 0 and (line + 1 == lines): c = PADDING + c self.print_color(c, end=end, color=color) self.print_color(&apos;--&apos;*chars_in_line) def print_color(self, message, end=&apos;\n&apos;, color=Red): print(&apos;&#123;&#125;&#123;&#125;\033[0m&apos;.format(color, message), end=end) def reset_data_to_init(self): self.ask_string = &apos;&apos; self.answers.clear() self.index_char_dict.clear() self.count = 0 self.auto_send_count = 0 self.answer_2chars_count = 0 self.answer_indexs_dict.clear() self.char_indexs_dict.clear() self.error_answers.clear()addons = [ Chengyu()]# if __name__ == &quot;__main__&quot;:# c = Chengyu()# ask_string = &apos;腊见家义降德若功赎仁判悲生升道肘两身乐极尽立罪春命明回人捉襟性暗&apos;# c.ask_string = ask_string# c.find_answers_v2(ask_string)# c.print_answers() chengyu.text 12345678一劳永逸一掷千金一曝十寒一石二鸟一筹莫展一落千丈一衣带水一语破的 注意：self.dictpath = &#39;/Users/xxx/chengyu.text&#39; 一定要修改成你自己的chengyu.text所在路径 运行效果 参考 WebSocket 教程 https://kaazing.com/demos/ https://github.com/mitmproxy/mitmproxy/blob/master/examples/simple/websocket_messages.py https://github.com/mitmproxy/mitmproxy/blob/master/examples/complex/websocket_inject_message.py]]></content>
  </entry>
  <entry>
    <title><![CDATA[mitmproxy与charles的抓包应用]]></title>
    <url>%2F2019%2F09%2F29%2Fmitmproxy-and-charles-use%2F</url>
    <content type="text"><![CDATA[[TOC]问题mitmproxy是命令行界面，不太方便查看，自己遇到的问题有： 在Flow Details界面不知道用哪个快捷键查看下一条或上一条网络请求详情 json中的中文显示为 \ua9b4 或 ？不能看清是哪个中文 不知道怎么复制界面中显示的内容 Charles的编程能力弱把Charles和mitmproxy结合起来使用，可以查看方便、编程扩展 环境电脑和手机都连接到同一个Wi-Fi, 比如TP_LINK_629F电脑: ip=192.168.1.100; 运行着Charles、mitmproxyCharles: 192.168.1.100:8888mitmproxy: 192.168.1.100:8080手机: 设置代理地址为Charles的地址192.168.1.100:8888 Charles - External Proxy Settings功能开启： Web Proxy(HTTP) - Web Proxy Server设置为mitmproxy的地址192.168.1.100:8080 Secure Web Proxy(HTTPS) - Secure Web Proxy Server设置为mitmproxy的地址192.168.1.100:8080 手机 Charles - External Proxy Settings 应用应用：自动生成接口的python代码 以趣头条App为例：阅读得积分的接口为: https://api.1sapp.com/readtimer/report自动生成的代码大约如下： 12345678910111213141516171819def readtimer_report(self): headers = &#123; &apos;User-Agent&apos;: &apos;qukan_android;retrofit/2.4.0 okhttp/3.11.0;os/7.0 M5 Note Meizu;device/862546036581345;version/3.9.41.000.0904.1121;channel/012&apos;, &apos;Host&apos;: &apos;api.1sapp.com&apos;, &apos;Accept-Encoding&apos;: &apos;gzip&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;, &#125; params = &#123; &apos;qdata&apos;: &apos;NzVFNkE3Mjc0RjEzRkYwRTM5OTEzNjAyRUZBMDMzQTAuY0dGeVlXMGZPR0kyTldKalltTXRNVGczT1MwME9EZGlMVGszT0RBdE1EUmlOVEV3TWpOak9UazRIblpsY25OcGIyNGZNVEVlY0d4aGRHWnZjbTBmWVc1a2NtOXBaQjVsWXg4eC46LxvyIvgD62/T93SlANmywpigTwlOwcfCHe0iZ1D8mH1zpslt2JCRPdiHOj1M20bU0zDX0odUOBig6Kt51mheNJuQYeDvp15R8RSGTT3LR9s55nBCGvWyTLq+3pjEvkyERElR9E2I384/nHQR4iqxqv7LKQ4rBA0R6bNG8sksHqNl1izSbF87G/4/Qw5vVYcuNUfU0BM6vvIbsy2CTPWlJ51YCzadQZZLONuaYTpyhuOiUV4vnx6qkvpYDNp9XpPPjbXxJAb7fikqjWSdyx167hXDPzUkNZGndjZsv7kQANDkIk2Dm+g5YW1I49xnkOzJkmxvyrLevnsSb9S5fSEUEyfq0GlPHE0RRBeSjFxVltH1zdZraTtk13Z+MvA7HBYQONz/0OwyMnujc1Ety91uKh6YCCVEDvBO+RTOzoRDa3nlRo3FTo9OeRBsyL20qIP24977MMYXEoxinTuwNonipCjnjSYIrhOu6cyv7uxuLd6FxtmTsydawNGMPI/K+habIKXNUFsQMCUcAGhYpoKQJvkQqHEq6lPyZZzXDot1EsN6bsGj56xQdiuJZLMFyZaGNR6E9FmVlI0LAVT8ttVpOvs+5f08T0iMxMNb0VQk6DOySpYHp7EVjc9YFpPcVxj8aXvuTjoPkaNGhSKQ0fgBd8HVRLslcnzX0QLJkTuU7NQ9aili6m2M2hWvh/q8ghWrvtLT+izCiFNKHE+4GTC9J6jqgyjHsXkAjcOSBAaIXMQKnOd664hdoR2GqV+GAy95fc5zZCJ7EFvzmTbJQrpMOwW+Y2NvYPZtgjw1uJEyU7AR7nVw7VqMjPpCDYeWBWoQ1W4OjlXTqgBR4MIu1sTag6a+my/0hItf91SNa58zCN3YmE2NnsWwwiCC+ZP91moV/KqPwX3vMLKW4/3Vsziqe8gl&apos;, &#125; data = &#123; &#125; url = &apos;http://api.1sapp.com/readtimer/report&apos; result = self._get(url, headers=headers, params=params, data=data) return result 应用步骤： 手机按上面环境设置好代理地址 在电脑上启动Charles，Charles按上面环境设置 在电脑上启动mitimproxy, 启动命令如下：mitmproxy -s gen_code_mitm.py 文件gen_code_mitm.py内容参考下面 在手机趣头条App阅读文章或看视频一定时间 会在~/Desktop/api/目录下生成一个叫readtimer_report.text 把readtimer_report.text的相应代码复制粘帖到文件qu_tou_tiao.py中 按需要修改自动生成的代码为希望的样子 运行qu_tou_tiao.py 注意： readtimer_report.text的名字和所在目录是由代码gen_code_mitm.py决定的，请自行阅读修改 readtimer_report方法名由代码gen_code_mitm.py决定的，请自行阅读修改 对body为复杂json格式的代码自动生成会有错误，有能力的自行修改 readtimer/report这个接口自动生成的代码数据是不能重复获取积分的，这里只是演示 文件文件qu_tou_tiao.py: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&apos;&apos;&apos;代码模板&apos;&apos;&apos;import requestsimport jsonimport logginglogging.basicConfig(format=&apos;%(asctime)s:%(message)s&apos;, datefmt=&apos;%m-%d %H:%M:%S&apos;, level=logging.INFO)class User(object): def __init__(self): pass def api_need_implement(self): pass def _header(self): return &#123; &apos;User-Agent&apos;: &apos;&apos;, &apos;Cookie&apos;:self.cookie &#125; @staticmethod def _post(url, data=None, json=None, p=logging.warning, **kwargs): res = requests.post(url, data=data, **kwargs) result = res.text p(res.json()) logging.info(&apos;&apos;) return result @staticmethod def _get(url, params=None, p=logging.warning, **kwargs): res = requests.get(url, params=params, **kwargs) result = res.text p(json.loads(result)) logging.info(&apos;&apos;) return resultdef genUsers(): yield User()if __name__ == &quot;__main__&quot;: for user in genUsers(): user.api_need_implement() 文件gen_code_mitm.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import jsonimport refrom urllib.parse import urlparsefrom mitmproxy import ctxfrom mitmproxy import flowfilterfrom mitmproxy import http&apos;&apos;&apos;生成接口python代码&apos;&apos;&apos;class GenCode(object): def __init__(self): ctx.log.info(&apos;__init__&apos;) # 趣头条 urls = [ r&apos;taskcenter/getListV2&apos;,#tab页：任务 r&apos;readtimer/report&apos;, ] self.qu_tou_tiao = flowfilter.parse(&apos;|&apos;.join(urls)) # 百度 - 全民小视频 urls = [ r&apos;mvideo/api&apos;, # 每日签到 ] self.quan_ming = flowfilter.parse(&apos;|&apos;.join(urls)) self.flowfilters = [ self.qu_tou_tiao, self.quan_ming, ] def load(self, loader): ctx.log.info(&apos;event: load&apos;) def configure(self, updated): ctx.log.info(&apos;event: configure&apos;) def running(self): ctx.log.info(&apos;event: running&apos;) def done(self): ctx.log.info(&apos;event: done&apos;) def response(self, flow: http.HTTPFlow): if any( [ filter(flow) for filter in self.flowfilters ] ): request: http.HTTPRequest = flow.request parse_result = urlparse(request.url) url_path = parse_result.path function_name = re.sub(r&apos;[/-]&apos;,&apos;_&apos;, url_path).strip(&apos;_&apos;) headers_code = self.headers_string(flow) params_code = self.params_string(flow) data_code = self.data_string(flow) path = f&apos;&apos;&apos;/Users/zhoujie/Desktop/api/&#123;function_name&#125;.text&apos;&apos;&apos; with open(path, &apos;a&apos;) as f: print(f&apos;&apos;&apos;# ---------------------&apos;&apos;&apos;,file=f) code = f&apos;&apos;&apos;def &#123;function_name&#125;(self): &#123;headers_code&#125; &#123;params_code&#125; &#123;data_code&#125; url = &apos;&#123;request.scheme&#125;://&#123;request.pretty_host&#125;&#123;url_path&#125;&apos; result = self._&#123;request.method.lower()&#125;(url, headers=headers, params=params, data=data) return result &apos;&apos;&apos; f.write(code) print(f&apos;&apos;&apos;Response:&apos;&apos;&apos;,file=f) print(f&apos;&apos;&apos;&#123;flow.response.text&#125;&apos;&apos;&apos;,file=f) print(f&apos;&apos;&apos;# ---------------------\n\n&apos;&apos;&apos;,file=f) def headers_string(self, flow: http.HTTPFlow): lines = &apos;&apos; for key,value in flow.request.headers.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; s = f&apos;&apos;&apos;headers = &#123;&#123;&#123;lines&#125;\n\t&#125;&#125;&apos;&apos;&apos; return s def params_string(self, flow: http.HTTPFlow): lines = &apos;&apos; for key,value in flow.request.query.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; s = f&apos;&apos;&apos;params = &#123;&#123;&#123;lines&#125;\n\t&#125;&#125;&apos;&apos;&apos; return s def data_string(self, flow: http.HTTPFlow): &apos;&apos;&apos; Content-Type: application/x-www-form-urlencoded Content-Type: application/json; charset=utf-8 Content-Type: text/plain;charset=utf-8 &apos;&apos;&apos; lines = &apos;&apos; # [urlencoded_form, multipart_form, plan, json]取其一 for key,value in flow.request.urlencoded_form.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; for key,value in flow.request.multipart_form.items(): key = key.decode(encoding=&apos;utf-8&apos;) value = value.decode(encoding=&apos;utf-8&apos;) lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &apos;&#123;value&#125;&apos;,&quot; # Todo:复杂json数据还不能代码化 if &apos;application/json&apos; in flow.request.headers.get(&apos;content-type&apos;,&apos;&apos;): d = json.loads(flow.request.text) for key,value in d.items(): lines += f&quot;\n\t\t&apos;&#123;key&#125;&apos;: &#123;value&#125;,&quot; s = f&apos;&apos;&apos;data = &#123;&#123;&#123;lines&#125;\n\t&#125;&#125;&apos;&apos;&apos; return s addons = [ GenCode()]]]></content>
      <tags>
        <tag>charles</tag>
        <tag>mitmproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles的应用]]></title>
    <url>%2F2019%2F09%2F28%2FCharles%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC]Rewrite应用案例01问题：今日头条极速版App每天的阅读推送文章任务因为每天收到的推送很少，因而不能得很高的积分，怎样把普通文章的阅读变为推送文章的阅读呢？思考：对比普通文章的阅读与推送文章的阅读发出的网络数据，找出差异普通文章的阅读与推送文章的阅读达到奖励标准时，都用相同的接口https://is.snssdk.com/score_task/v1/task/get_read_bonus/ 12345# 普通阅读文章/视频https://is.snssdk.com/score_task/v1/task/get_read_bonus/?fp=xxx&amp;...&amp;group_id=6689697061983486472# 推送文章的阅读https://is.snssdk.com/score_task/v1/task/get_read_bonus/?fp=xxx&amp;...&amp;&amp;impression_type=push&amp;group_id=6689697061983486472 对比上面的接口数据发现：推送阅读只比普通阅读多出了impression_type=push的Query String 解决：用Charles的Rewrite功能Add Query Param来增加impression_type=push解决问题 上面的get_read_bonus重写规则Export导出的get_read_bonus.xml文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos; ?&gt;&lt;?charles serialisation-version=&apos;2.0&apos; ?&gt;&lt;rewriteSet-array&gt; &lt;rewriteSet&gt; &lt;active&gt;true&lt;/active&gt; &lt;name&gt;get_read_bonus&lt;/name&gt; &lt;hosts&gt; &lt;locationPatterns&gt; &lt;locationMatch&gt; &lt;location&gt; &lt;protocol&gt;https&lt;/protocol&gt; &lt;host&gt;is.snssdk.com&lt;/host&gt; &lt;path&gt;/score_task/v1/task/get_read_bonus/&lt;/path&gt; &lt;/location&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/locationMatch&gt; &lt;/locationPatterns&gt; &lt;/hosts&gt; &lt;rules&gt; &lt;rewriteRule&gt; &lt;active&gt;true&lt;/active&gt; &lt;ruleType&gt;8&lt;/ruleType&gt; &lt;matchHeader&gt;&lt;/matchHeader&gt; &lt;matchValue&gt;&lt;/matchValue&gt; &lt;matchHeaderRegex&gt;false&lt;/matchHeaderRegex&gt; &lt;matchValueRegex&gt;false&lt;/matchValueRegex&gt; &lt;matchRequest&gt;false&lt;/matchRequest&gt; &lt;matchResponse&gt;false&lt;/matchResponse&gt; &lt;newHeader&gt;impression_type&lt;/newHeader&gt; &lt;newValue&gt;push&lt;/newValue&gt; &lt;newHeaderRegex&gt;false&lt;/newHeaderRegex&gt; &lt;newValueRegex&gt;false&lt;/newValueRegex&gt; &lt;matchWholeValue&gt;false&lt;/matchWholeValue&gt; &lt;caseSensitive&gt;false&lt;/caseSensitive&gt; &lt;replaceType&gt;2&lt;/replaceType&gt; &lt;/rewriteRule&gt; &lt;/rules&gt; &lt;/rewriteSet&gt;&lt;/rewriteSet-array&gt; 重写规则设置正确与否验证： 在上面的Notes列上会显示Rewrite Tool: query added &quot;impression_type: push&quot; 应用： 打开Charles并生效上面的Rewrite设置 手机设置代理为Charles的代理地址 正常阅读普通文章\视频达到奖励时点 查找我的收益页面，验证成功与否 案例02问题：趣消除、趣键盘、东方头条等App都看广告得金币，怎样减少广告的时间？ 思考：广告是哪里来的？广告时长是怎么来的？当点击App上的按钮弹出广告时，3个App都调用了接口： 1https://is.snssdk.com/api/ad/union/sdk/get_ads/ 响应如下： 123456789101112131415&#123;...... &quot;video&quot;: &#123; &quot;cover_height&quot;: 1280, &quot;cover_url&quot;: &quot;http://sf1-ttcdn-tos.pstatp.com/img/mosaic-legacy/1be91000a8c62c6ba6221~noop.jpg&quot;, &quot;cover_width&quot;: 720, &quot;endcard&quot;: &quot;https://www.toutiaopage.com/union/endcard/1629848424707111/?rit=909946692\u0026req_id=ED6EC127-C359-4C18-A41E-3A5F6F499250u3183\u0026ad_sdk_version=1.9.9.0\u0026os=ios\u0026lang=cn\u0026style_id=1104\u0026ad_id=1629844369912839\u0026_toutiao_params=%7B%22cid%22%3A1629848424707111%2C%22device_id%22%3A9724339963504202%2C%22log_extra%22%3A%22%7B%5C%22ad_price%5C%22%3A%5C%22XOub4AAGRWZc65vgAAZFZgz-hMMMgth42hwxAg%5C%22%2C%5C%22convert_id%5C%22%3A1629408290774020%2C%5C%22orit%5C%22%3A900000000%2C%5C%22req_id%5C%22%3A%5C%22ED6EC127-C359-4C18-A41E-3A5F6F499250u3183%5C%22%2C%5C%22rit%5C%22%3A909946692%7D%22%2C%22orit%22%3A900000000%2C%22req_id%22%3A%22ED6EC127-C359-4C18-A41E-3A5F6F499250u3183%22%2C%22rit%22%3A909946692%2C%22sign%22%3A%22D41D8CD98F00B204E9800998ECF8427E%22%2C%22uid%22%3A9724339963504202%2C%22ut%22%3A14%7D\u0026append=%7B%22openurl%22%3A%22%22%2C%22postdata%22%3A%5B%7B%22__type__%22%3A%22req_id%22%2C%22cid%22%3A1629848424707111%2C%22req_id%22%3A%22ED6EC127-C359-4C18-A41E-3A5F6F499250u3183%22%2C%22rit%22%3A909946692%7D%5D%7D&quot;, &quot;resolution&quot;: &quot;720x1280&quot;, &quot;size&quot;: 5628226, &quot;video_duration&quot;: 29.04, &quot;video_url&quot;: &quot;http://vd2.bdstatic.com/mda-jesntzw6569xqudw/mda-jesntzw6569xqudw.mp4&quot; &#125; &#125;],......&#125; 广告就是从上面的接口获取而来的，广告时长由video_url字段对应的mp4的时长决定 解决：用Charles的Rewrite功能Body替换video_url字段的值 12345Match Value:&quot;video_url&quot;:&quot;(.+)&quot;&#125;Replace Value:&quot;video_url&quot;:&quot;http://vd2.bdstatic.com/mda-jesntzw6569xqudw/mda.mp4&quot;&#125; 提供一个只有3秒的素材： 1http://vd2.bdstatic.com/mda-jesntzw6569xqudw/mda-jesntzw6569xqudw.mp4 案例03问题：章鱼输入法App有看广告得金币，没有像案例02那样找到相应的接口api返回广告视频的URL，怎样减少广告的时间？ 思考：尝试替换广告视频的请求比如广告视频的请求如下： 1234Get https://v3-ad.ixigua.com/.../video/m/.../toutiao.mp4替换为只有3秒的视频地址Get http://vd2.bdstatic.com/.../3seconds.mp4 解决：用Charles的Rewrite功能URL替换请求 案例04问题：扶我起来学数学App的作战休息区有一个游戏伪装者，在上报成绩时，接口有hash字段，修改成绩字段，hash会验证不通过，达到了防止伪造成绩的功能，怎样在hash前伪造成绩？思考：hash算法一般难破解，与其破解hash算法，不如转变思路：修改传入hash的值 12value肯定与成绩相关hash(value) 那value具体是怎么样的呢？通过抓包的数据可以判定为是个h5游戏，在js代码中可能包含相要的答案 在浏览器中打开上面中的game.html验证确实是一个h5游戏： 解决： 用Charles的Mirror功能把抓包的数据自动保存为文件，再在文本编辑器中检查代码 在game.html文件中查找rest/game_report，因为有这个网络包，所以先查找这个关键字，结果如下： 123456function _gameReport(score, callBack, hash, time)&#123; var oAjax = null; //这里进行HTTP请求 oAjax = new XMLHttpRequest(); oAjax.open(&apos;post&apos;,HOSTURLAPI+&quot;/rest/game_report&quot;+&quot;?uid=&quot;+UID+&quot;&amp;gameid=&quot;+GAMEID+&quot;&amp;score=&quot;+score+&quot;&amp;tm=&quot;+time+&quot;&amp;hash=&quot;+hash,true);&#125; 查找_gameReport函数的调用者 1234567891011function gameReport(score, callBack)&#123; var timeData = new Date().getTime(); var hashValue = UID+GAMEID+score+timeData; var hash = &apos;&apos;; dsBridge.call(&apos;hashCode&apos;,hashValue,function(data)&#123; hash = data; _gameReport(score, callBack, hash, timeData); &#125;);&#125;gameReport(b[0], function(success, old_score)&#123;&#125;) js代码调用到App的hashCode方法，hashValue = UID+GAMEID+score+timeData用Charles的Rewrite功能Body替换： 12345Match Value:gameReport(b[0]Replace Value:gameReport(&apos;99&apos; 成绩已修改，hash验证已通过 Mirror应用文档：https://www.charlesproxy.com/documentation/tools/mirror/ The Mirror tool saves responses to disk as they are received, creating a mirror copy of websites as you browse them. Mirror把响应保存为文件到硬盘上 No Caching 和 Block Cookies应用在案例：扶我起来学数学App的伪装者游戏通过Rewrite功能修改了js文件中的内容；但有时js文件不是每次都会传输，而是使用了缓存，这时Rewrite功能就失效了，因为没有发生网络请求；通过No Caching 和 Block Cookies使网络请求每次都发生 Map Local应用 Map Local应用场景 修改js文件来改变App行为: 1. 使用No Caching 和 Block Cookies功能保证js文件通过网络请求加载到App 2. 使用Mirror功能把js文件保存到电脑上 3. 使用Map Local功能使App加载修改后的js文件]]></content>
      <tags>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mitmproxy的使用]]></title>
    <url>%2F2019%2F09%2F28%2Fmitmproxy%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC]mitmproxy的使用mitmproxy is a free and open source interactive HTTPS proxy.官网：https://mitmproxy.org/安装：pip3 install mitmproxy 或 brew install mitmproxy安装后有3个命令行工具：mitmproxy, mitmdump, mitmweb 这里不介绍mitmweb的使用，mitmproxy与mitmdump的功能重点：mitmproxy：交互式；查看流量数据(请求与响应)；执行自定义脚本mitmdump：执行自定义脚本，脚本在Mitmproxy中叫做Addon 使用mitmproxy：因为是命令行界面，所以需要记住一些快捷键使用mitmdump：偏向编写python代码 通过一个典型的调用，来认识下Mitmproxy下的核心概念： 1➜ ~ mitmproxy --set scripts=ad_short_mitm.py &apos;~u baidu\.com&apos; 在Mitmproxy的叫法 set Command scripts Options ad_short_mitm.py Addon ‘~u baidu\.com’ Filter expressions mitmproxy1➜ ~ mitmproxy 输入上面命令，启动mitmproxy并显示Flows界面： Flows界面 快捷键 第1个也是最重要的快捷键：?: 进入Help界面： 进入Help界面 第2个重要的快捷键：:: Command prompt,进入命令输入模式 进入命令输入模式 可以输入的命令：可以在Command Reference界面查看 可以按tab来命令补全：比如输入flow.m；再按tab; 补全为flow.mark 可以按tab来路径补全 按enter执行命令 常用的命令可以用快捷键，不用进入命令输入模式，省去输入的时间 界面间跳转快捷键 快捷键 界面 截图 ? Help界面 K Key Bindings界面 P Flow Details界面 E Events界面 C Command Reference界面 O Options界面 注意：上面的快捷键，都是大写字母，mitmproxy的快捷键是区分大小写的 Flows界面居然没有快捷键？ 导航快捷键 快捷键 command 说明 q console.view.pop 返回：界面间的返回 g console.nav.start 跳到第一行 G console.nav.end 跳到最后一行 h console.nav.left j console.nav.down 跳到下一行 k console.nav.up 跳到上一行 l console.nav.right space console.nav.pagedown ctrl b console.nav.pageup ctrl f console.nav.pagedown tab console.nav.next g\G\j\k等这样的导航键是通用的：在Flows、Events、Command、Options等界面都能用 刚开始学命令行界面时，有这么命令、快捷键要记，没记住怎么办？这里介绍下mitmproxy的--no-server, -n应用 123456➜ ~ mitmproxy --helpusage: mitmproxy [options]...Proxy Options: --no-server, -n --server Start a proxy server. Enabled by default. 第1个Terminal窗口里正常启动mitmproxy：➜ ~ mitmproxy 开启第2个Terminal窗口带--no-server选项启动mitmproxy：➜ ~ mitmproxy --no-server；按K/C/O/?查看快捷键、Command、Options、帮助 第2个mitmproxy专门用于查看快捷键、Command、Options、帮助 案例实战以东方头条App - 幸运大转盘这个游戏为实战 东方头条App - 幸运大转盘 1.点击’领取金币’：会发出https://…/zhuanpan/get_zhuanpan_new网络请求 2.点击’立即领取’：会发出https://…/zhuanpan/get_gold网络请求 应用目的：通过mitmproxy的replay功能来减少手动操作时间知识点：Filter expressions, Options, Command 1.启动mitmproxy 1➜ ~ mitmproxy 2.点开东方头条App到幸运大转盘界面 3.点击’领取金币’；点击’立即领取’； 问题：这时候mitmrpoxy的Flow界面已包含上面的网络请求，网络请求非常多，怎么找到需要的请求 解答：应用mitmrpoxy的Filter expressions 4.按f快捷键：设置view_filter这个Option 按f快捷键, 设置view_filter * 5.输入~u zhuanpan, 按回车执行命令 输入~u zhuanpan 知识点：~u zhuanpan是Filter expressions：~u regex，用来过滤URL符合regex正则表达式的网络请求；可以按？跳转到Help界面查看全部的Filter expressions 6.用j导航快捷键定位到zhuanpan/get_zhuanpan_new网络请求；按下m快捷键将这条网络请求标记 按下m标记网络请求 7.用同样的操作，标记zhuanpan/get_gold网络请求 按下m标记网络请求 8.按:快捷键, 进入命令输入模式；输入rep, 按tab补全命令; 输入@marked; 按回车执行命令 按tab补全命令 出于演示使用mitmrpoxy的目的，才增加了许多不必要的步骤；简洁方法： 去除步骤4、5、6、7 步骤8改为: replay.client &quot;(~u zhuanpan/get_zhuanpan_new) | (~u zhuanpan/get_gold)&quot; 案例到此结束，小结下用到的快捷键、命令： 快捷键 command 说明 f : set view_fliter= 只显示符合条件的网络请求 m flow.mark.toggle @focus Toggle mark on this flow : replay.client @marked 重放多条标记的网络请求 相关快捷键： 快捷键 界面 command 说明 M flowlist view.marked.toggle Toggle viewing marked flows U flowlist flow.mark @all false Un-set all marks r flowlist replay.client @focus Replay this flow 一些用到Filter expressions的Options:view_filter、save_stream_filter、intercept 相关文档：https://docs.mitmproxy.org/stable/concepts-options/https://docs.mitmproxy.org/stable/concepts-filters/ 问题上面的实战有以下几个问题： 第1次收集操作时，不是每次都抽到金币，也有可能抽到广告；怎样每次都跳过广告？ 游戏有20次机会，要手动输入多次replay.client @marked才能把20次机会用完；怎样才能减少手动操作？ 这些问题我们通过编写脚本来解决。这里使用mitmproxy的其它功能为编写脚本提供方便把实战的已被标记的2个网络请求保存为文件，方便查看： 快捷键 界面 command 说明 w flowlist console.command save.file @shown Save listed flows to file 1.按w快捷键, 把@shown修改为@marked; 指定保存路径；按回车执行命令 按w保存为文件 输入路径时，可以按tab来补全路径 最好不要使用~：像我自己Mac上输入~/zhuanpan.mitm，没有保存成功；当然你也可以测试下使用~的路径能否保存成功 输入的文件的后缀名是可以随意指定的；保存的文件为二进制格式 2.开启第2个Terminal窗口带–no-server选项启动mitmproxy 1➜ ~ mitmproxy --no-server 快捷键 界面 command 说明 L flowlist console.command view.load Load flows from file 3.按L快捷键, 把步骤1保存的文件加载进来 按L加载文件 好了，编写脚本的准备工作结束！小结下用到的快捷键、命令： 快捷键 界面 command 说明 w flowlist console.command save.file @shown Save listed flows to file L flowlist console.command view.load Load flows from file 相关快捷键： 快捷键 界面 command 说明 e flowlist console.command export.file {choice} @focus Export this flow to file 快捷键w与e的区别 w e 文件为二进制文件 文件为文本文件 保存的信息完整 只保存请求信息，不保存响应信息 能一次保存多条网络请求信息 一次只能保存一条网络请求信息 mitmdumpMitmproxy是用python实现的，编写相应的Addon脚本也是用python shell脚本先用在mitmproxy的e快捷键来辅助编写shell脚本，来解决下上面的实战问题 用e快捷键分别保存zhuanpan/get_zhuanpan_new、zhuanpan/get_gold网络请求为文件get_zhuanpan_new.sh、get_gold.sh get_zhuanpan_new.sh文件内容：[get_gold.sh内容类似，不再列出] 1curl -H &apos;Host:zhuanpan.dftoutiao.com&apos; -H &apos;Content-Type:application/x-www-form-urlencoded&apos; -H &apos;Connection:keep-alive&apos; -H &apos;Accept:*/*&apos; -H &apos;User-Agent:DFTT/2.4.8 (iPhone; iOS 12.3.1; Scale/3.00)&apos; -H &apos;Accept-Language:zh-Hans-CN;q=1, en-CN;q=0.9, zh-Hant-CN;q=0.8&apos; -H &apos;Content-Length:484&apos; -H &apos;Accept-Encoding:br, gzip, deflate&apos; -X POST &apos;https://zhuanpan.dftoutiao.com/zhuanpan/get_zhuanpan_new&apos; --data-binary &apos;accid=834536089&amp;appqid=AppStore190602&amp;apptypeid=DFTT&amp;appver=2.4.8&amp;device=iPhone%206s%20Plus%20%28A1634/A1687%29&amp;deviceid=AE9418A1-561A-4F5C-AF05-1EC222A50CF3&amp;fr=rwzx&amp;ime=F2B14555-E2EB-4556-B757-2C55799C92C2&amp;lt=d2RlWExGb015UjRqSkxMZk0rRkYwcTAzd0I3RmErMWRLbzZsYTc4dkFtakxLMmgvdW9xWFhYUEFNdU9XTHZMV3F6cWNhVXRPalBSMkJNUHlvTktRbnc9PQ%3D%3D&amp;network=wifi&amp;num=57&amp;os=iOS%2012.3.1&amp;position=%E6%B5%99%E6%B1%9F&amp;sign=5aac4e159e8d205c084c9f9e6cf4e41f&amp;softname=DFTTIOS&amp;softtype=TouTiao&amp;ts=1564368354&apos; 把get_zhuanpan_new.sh、get_gold.sh的内容合并到最终的文件中zhuanpan.sh 123456789101112131415#!/usr/bin/env bashfunction zhuanpan&#123; # mitmproxy用快捷键e导出的get_zhuanpan_new.sh文件内容原样写到这 curl -H 'Host:zhuanpan.dftoutiao.com' -H 'Content-Type:application/x-www-form-urlencoded' -H 'Connection:keep-alive' -H 'Accept:*/*' -H 'User-Agent:DFTT/2.4.8 (iPhone; iOS 12.3.1; Scale/3.00)' -H 'Accept-Language:zh-Hans-CN;q=1, en-CN;q=0.9, zh-Hant-CN;q=0.8' -H 'Content-Length:484' -H 'Accept-Encoding:br, gzip, deflate' -X POST 'https://zhuanpan.dftoutiao.com/zhuanpan/get_zhuanpan_new' --data-binary 'accid=834536089&amp;appqid=AppStore190602&amp;apptypeid=DFTT&amp;appver=2.4.8&amp;device=iPhone%206s%20Plus%20%28A1634/A1687%29&amp;deviceid=AE9418A1-561A-4F5C-AF05-1EC222A50CF3&amp;fr=rwzx&amp;ime=F2B14555-E2EB-4556-B757-2C55799C92C2&amp;lt=d2RlWExGb015UjRqSkxMZk0rRkYwcTAzd0I3RmErMWRLbzZsYTc4dkFtakxLMmgvdW9xWFhYUEFNdU9XTHZMV3F6cWNhVXRPalBSMkJNUHlvTktRbnc9PQ%3D%3D&amp;network=wifi&amp;num=57&amp;os=iOS%2012.3.1&amp;position=%E6%B5%99%E6%B1%9F&amp;sign=5aac4e159e8d205c084c9f9e6cf4e41f&amp;softname=DFTTIOS&amp;softtype=TouTiao&amp;ts=1564368354' # mitmproxy用快捷键e导出的get_gold.sh文件内容原样写到这 curl -H 'Host:zhuanpan.dftoutiao.com' -H 'Content-Type:application/x-www-form-urlencoded' -H 'Connection:keep-alive' -H 'Accept:*/*' -H 'User-Agent:DFTT/2.4.8 (iPhone; iOS 12.3.1; Scale/3.00)' -H 'Accept-Language:zh-Hans-CN;q=1, en-CN;q=0.9, zh-Hant-CN;q=0.8' -H 'Content-Length:487' -H 'Accept-Encoding:br, gzip, deflate' -X POST 'https://zhuanpan.dftoutiao.com/zhuanpan/get_gold' --data-binary 'accid=834536089&amp;appqid=AppStore190602&amp;apptypeid=DFTT&amp;appver=2.4.8&amp;device=iPhone%206s%20Plus%20%28A1634/A1687%29&amp;deviceid=AE9418A1-561A-4F5C-AF05-1EC222A50CF3&amp;fr=rwzx&amp;ime=F2B14555-E2EB-4556-B757-2C55799C92C2&amp;isfirst=0&amp;lt=d2RlWExGb015UjRqSkxMZk0rRkYwcTAzd0I3RmErMWRLbzZsYTc4dkFtakxLMmgvdW9xWFhYUEFNdU9XTHZMV3F6cWNhVXRPalBSMkJNUHlvTktRbnc9PQ%3D%3D&amp;network=wifi&amp;os=iOS%2012.3.1&amp;position=%E6%B5%99%E6%B1%9F&amp;sign=c6f61f80d1c001ac5382ef73632e0e9e&amp;softname=DFTTIOS&amp;softtype=TouTiao&amp;ts=1564368376'&#125;for ((i=0; i&lt;20; i++));do zhuanpandone ok，shell脚本以编写完成 python脚本关于Addon的概念可以查看：https://docs.mitmproxy.org/stable/addons-overview/ 编写Addon脚本写些什么呢？先上一下模板： 12345678910111213141516171819202122from mitmproxy import ctxfrom mitmproxy import flowfilterfrom mitmproxy import httpfrom mitmproxy import addonmanagerclass Myaddon(object): def __init__(self): pass def load(self, entry: addonmanager.Loader): pass def request(self, flow: http.HTTPFlow): pass def response(self, flow: http.HTTPFlow): passaddons = [ Myaddon()] 编写Addon脚本:就是选择性的实现上面的方法 具体都有哪些方法可以选择性实现，可以查看如下文档： 文档 https://docs.mitmproxy.org/stable/addons-events/ 源代码 docs/src/examples/addons/events.py 源代码 mitmproxy/eventsequence.py 开始实现Addon脚本： 新建文件zhuangpan_mitm.py, 实现__init__方法： 12345678910111213141516171819import jsonimport refrom mitmproxy import ctxfrom mitmproxy import flowfilterfrom mitmproxy import httpclass Zhuangpan(object): def __init__(self): self.filter = flowfilter.parse(r&apos;(~u zhuanpan/get_zhuanpan_new) | (~u zhuanpan/get_gold)&apos;) self.new_fliter = flowfilter.parse(r&apos;~u zhuanpan/get_zhuanpan_new&apos;) self.get_fliter = flowfilter.parse(r&apos;~u zhuanpan/get_gold&apos;) self.flows = [] self.urls = set() self.remain = 0addons = [ Zhuangpan()] 这里用到了Mitmproxy的api:flowfilter.parse： 12345678910# mitmproxy/flowfilter.py文件def parse(s: str) -&gt; TFilter:# 还定义了：def match(flt, flow): &quot;&quot;&quot; Matches a flow against a compiled filter expression. Returns True if matched, False if not. .... &quot;&quot;&quot; 实现request方法： 123456789class Zhuangpan(object): ... def request(self, flow: http.HTTPFlow): if flowfilter.match(self.filter, flow): url = flow.request.url if not url in self.urls: ctx.log.alert(url) self.flows.append(flow) self.urls.add(url) 实现response方法： 123456789101112131415class Zhuangpan(object): ... def response(self, flow: http.HTTPFlow): if flowfilter.match(self.new_fliter, flow): flow.response.replace(r&apos;&quot;gold&quot;:0&apos;, &apos;&quot;gold&quot;:999&apos;) text = flow.response.text data = json.loads(text) self.remain = data.get(&apos;data&apos;).get(&apos;cur_num&apos;) ctx.log.alert(&apos;remain count:&#123;&#125;&apos;.format(self.remain)) if flowfilter.match(self.get_fliter, flow): if self.remain &gt; 0 and len(self.urls) &gt;= 2: flows = [f.copy() for f in self.flows] ctx.master.commands.call(&quot;replay.client&quot;, flows) 使用ctx.log.xxx等方法来代替使用print或logging.warning等方法： 在mitmproxy中，ctx.log.xxx记录的信息会出现在Event界面, 而其它方法不会出现在Event界面 在mitmdump中，ctx.log.xxx记录的信息事件显示的顺序正确, 而其它方法显示的顺序不正确 使用123456➜ ~ mitmdump --scripts zhuangpan_mitm.pyLoading script zhuangpan_mitm.pyProxy server listening at http://*:8080 # --scripts SCRIPT, -s SCRIPT Execute a script. May be passed multiple times. 12345678mitmdump --set userid=zhj -s &quot;mitm_user_xxx.py&quot; -s math_mitm.py &apos;~u mapi.hddgood.com&apos;mitmdump --set replacements=&apos;/~s/&quot;video_url&quot;:&quot;(.+)&quot;&#125;/&quot;video_url&quot;:&quot;https://vd3.bdstatic.com/abc.mp4&quot;&#125;&apos;# 代码里可以调用ctx.master.commands.call(&quot;replay.client&quot;, [flow])ctx.master.commands.execute(&quot;view.focus.go 0&quot;) 其它问题：只关注某个域名下的流量，怎么设置？解决：ignore_hostshttps://docs.mitmproxy.org/stable/howto-ignoredomains/ 123456# Ignore everything but example.com and mitmproxy.org:--ignore-hosts &apos;^(?!example\.com)(?!mitmproxy\.org)&apos;正则表达式：反前瞻反前瞻：要匹配某个模式时，需要在它 后面找不到含有给定前瞻模式的内容foo(?!bar) Negative lookahead assertion. The pattern foo will only match if not followed by a match of pattern bar. 代码阅读源码地址：https://github.com/mitmproxy/mitmproxy mitmproxy/tools/_main.py 123456789101112131415161718192021222324252627282930313233343536373839404142入口方法：def mitmproxy(args=None) -&gt; typing.Optional[int]: run(console.master.ConsoleMaster)def mitmdump(args=None) -&gt; typing.Optional[int]: run(dump.DumpMaster) 主要代码def run(master_cls): opts = options.Options() master = master_cls(opts) pconf = proxy.config.ProxyConfig(opts) server = proxy.server.ProxyServer(pconf) master.server = server master.run() return master master.Master console.master.ConsoleMaster dump.DumpMaster web.master.WebMasterServer proxy.server.ProxyServer proxy.server.DummyServerMaster与Server关系： master.server = serverMaster和Server对象生成： Master(opts: options.Options) Server(config: config.ProxyConfig)ProxyConfig与Options关系： ProxyConfig(options: options.Options) 123456789101112131415161718开始运行： master.run() master.start() def start(self): if self.server: ServerThread(self.server).start()class ServerThread(basethread.BaseThread): def __init__(self, server): self.server = server address = getattr(self.server, &quot;address&quot;, None) super().__init__( &quot;ServerThread (&#123;&#125;)&quot;.format(repr(address)) ) def run(self): self.server.serve_forever() 12345678910111213141516171819202122232425262728293031323334353637383940线程： ServerThread connection_thread def connection_thread(self, connection, client_address): with self.handler_counter: try: self.handle_client_connection(connection, client_address) finally: close_socket(connection) def handle_client_connection(self, conn, client_address): h = ConnectionHandler( conn, client_address, self.config, self.channel ) h.handle() def handle(self): self.log(&quot;clientconnect&quot;, &quot;info&quot;) root_layer = None root_layer = self._create_root_layer() root_layer = self.channel.ask(&quot;clientconnect&quot;, root_layer) root_layer() self.log(&quot;clientdisconnect&quot;, &quot;info&quot;) def _create_root_layer(self): root_ctx = ... mode = self.config.options.mode if mode.startswith(&quot;upstream:&quot;): return modes.HttpUpstreamProxy elif mode == &quot;transparent&quot;: return modes.TransparentProxy(root_ctx) elif mode == &quot;regular&quot;: return modes.HttpProxy(root_ctx) 123456789101112131415161718192021222324252627282930313233343536373839addons的运行过程[生命周期][1]. &quot;load&quot;[2]. &quot;running&quot;[3]. &quot;configure&quot;[1]. &quot;load&quot;DumpMaster.__init__(self,options): super().__init__(options) self.addons.add(*addons.default_addons())AddonManager.add(self, *addons): for i in addons: self.chain.append(self.register(i)) AddonManager.register(self, addon): l = Loader(self.master) self.invoke_addon(addon, &quot;load&quot;, l) [2]. &quot;running&quot;master.run(): loop = asyncio.get_event_loop() self.run_loop(loop.run_forever) master.run_loop(self, loop): asyncio.ensure_future(self.running()) master.running(self): self.addons.trigger(&quot;running&quot;) [3]. &quot;configure&quot;class AddonManager: def __init__(self, master): self.lookup = &#123;&#125; self.chain = [] self.master = master master.options.changed.connect(self._configure_all) def _configure_all(self, options, updated): self.trigger(&quot;configure&quot;, updated) 参考https://stackoverflow.com/questions/51893788/using-mitmproxy-inside-python-script https://dev.to/kevcui/3-mitmproxy-tips-you-might-not-know-about-5dbg https://github.com/KevCui/mitm-scripts]]></content>
      <tags>
        <tag>charles</tag>
        <tag>mitmproxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS快速设置代理]]></title>
    <url>%2F2019%2F09%2F27%2Fios-switch-proxy%2F</url>
    <content type="text"><![CDATA[问题手动设置wifi的步骤非常长： 点击“设置” 点击“无线局域网” 点击已连接的wifi 点击“配置代理” 点击“手动” 定位服务器输入框，输入ip 定位端口输入框，输入port 点击“存储” 解决用iOS上的Shadowrocket和Mac上的Charles来快速设置代理iOS和Mac在同一wifi 启动Charles，假设代理地址为：192.168.0.100:8888 Shadowrocket设置全局路由为代理 Shadowrocket添加HTTP类型的节点 Shadowrocket打开连接 添加HTTP类型的节点: 结果:]]></content>
      <tags>
        <tag>代理</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的阅读列表]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%88%91%E7%9A%84%E9%98%85%E8%AF%BB%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基础 汇编语言入门教程 理解字节序 正则表达式30分钟入门教程 YAML 语言教程 理解OAuth 2.0 基于python flask详述 OAuth 2.0 的运作流程 RESTful API 最佳实践 算法 《我的第一本算法书》 极客时间-数据结构与算法之美 极客时间-算法面试通关40讲 可能是最容易理解的 KMP 教程 网络 极客时间-趣谈网络协议 《Wireshark网络分析就这么简单》 《Wireshark网络抓包从入门到熟练》 The First Few Milliseconds of an HTTPS Connection 为什么Wireshark无法解密HTTPS数据 curl 的用法指南 curl 网站开发指南 使用 curl 命令分析请求的耗时情况 在Linux中使用curl命令参数详解 Nginx 配置从零开始 https://www.open-open.com/news/view/19493be 协议 WebSocket 教程 SSH原理与运用（一）：远程登录 SSH原理与运用（二）：远程登录 SSH 端口转发教程 SSH 技巧 ssh密钥对登录安全吗？原理篇 针对不同主机使用不同 SSH Key JavaScript ECMAScript 6 入门 前端基础进阶系列 JavaScript深入系列 iOS iOS阅读列表 Python Python阅读列表 Node.js Node Cookbook Second Edition 深入浅出Node.js 后端 全文搜索引擎 Elasticsearch 入门教程 Elasticsearch 基本介绍及其与 Python 的对接实现 前端 Flask Web开发：基于Python的Web应用开发实战 Front-End Web Development The Big Nerd Ranch Guide Handlebars模板引擎 https://mrleo.gitbooks.io/books/content/resource/spy-debugger.html Shell xargs 命令教程 Bash 脚本 set 命令教程 命令行通配符教程 Pro Bash Programming, Second Edition linux命令行精选网 linux常用命令-帮助命令-授之以渔 Printing colors in the terminal Linux linux 网络虚拟化： network namespace 简介 Linux 的启动流程 Systemd 入门教程：命令篇 Systemd 入门教程：实战篇 详解 Linux 下的用户管理、用户组管理和权限管理 Docker 入门教程 图书 编译系统透视 SQL基础教程（第2版） 图解密码技术 深度学习入门：基于Python的理论与实现(英文名：Deep Learning From Scratch) Python深度学习(英文名：Deep Learning With Python) Python3网络爬虫开发实战 精通Scrapy网络爬虫 网站]]></content>
  </entry>
</search>
